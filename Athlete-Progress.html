<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Athlete Progress</title>
  <link rel="icon" type="image/svg+xml" href="favicon.svg">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
  <script src="auth.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    // Load exercises configuration
    let EXERCISES_CONFIG = [];
    fetch('exercises.json')
      .then(res => res.json())
      .then(data => {
        EXERCISES_CONFIG = data.exercises;
      })
      .catch(err => console.error('Failed to load exercises:', err));
  </script>
  <style>
    /* Progress page styling */
    .progress-container {
      max-width: 100%;
      width: 100%;
      margin: 0 auto;
      padding: 2rem;
      box-sizing: border-box;
    }

    .athlete-selector {
      display: flex;
      justify-content: center;
      margin-bottom: 2rem;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .athlete-selector.admin-only {
      display: none;
    }

    .athlete-dropdown {
      padding: 0.75rem 1.5rem;
      border-radius: 12px;
      border: 2px solid var(--hornet-green);
      background: white;
      color: var(--text-primary);
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      min-width: 200px;
    }

    .progress-content {
      display: none;
    }

    .progress-content.active {
      display: block;
    }

    .stats-overview {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 1.5rem;
      margin-bottom: 3rem;
    }

    .stat-card {
      background: linear-gradient(135deg, white 0%, #f8f9fa 100%);
      border-radius: 16px;
      padding: 1.5rem;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      border: 1px solid var(--border-light);
      text-align: center;
    }

    .stat-label {
      font-size: 0.9rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 0.5rem;
    }

    .stat-value {
      font-size: 2rem;
      font-weight: 800;
      color: var(--hornet-green);
    }

    .progress-section {
      background: white;
      border-radius: 16px;
      padding: 2rem;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      margin-bottom: 2rem;
      width: 100%;
      box-sizing: border-box;
    }

    .section-header {
      display: flex;
      align-items: center;
      margin-bottom: 1.5rem;
    }

    .section-icon {
      font-size: 1.5rem;
      margin-right: 0.75rem;
    }

    .section-title {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--hornet-green);
      margin: 0;
    }

    .exercise-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 1.5rem;
    }

    .exercise-card {
      background: #f8f9fa;
      border-radius: 12px;
      padding: 1.5rem;
      border: 1px solid var(--border-light);
      min-height: 450px;
    }

    .exercise-name {
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 1rem;
      text-align: center;
    }

    .chart-container {
      position: relative;
      height: 350px;
      margin-top: 1rem;
    }

    .metric-summary {
      display: flex;
      justify-content: space-around;
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid var(--border-light);
    }

    .metric-stat {
      text-align: center;
    }

    .metric-stat-label {
      font-size: 0.75rem;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .metric-stat-value {
      font-size: 1rem;
      font-weight: 700;
      color: var(--hornet-green);
      margin-top: 0.25rem;
    }

    .improvement {
      color: #28a745;
    }

    .decline {
      color: #dc3545;
    }

    .no-data {
      text-align: center;
      padding: 3rem;
      color: var(--text-secondary);
      font-size: 1.1rem;
    }

    /* Back button styling */
    .back-button {
      padding: 0.5rem 1rem;
      border-radius: 8px;
      border: 2px solid var(--hornet-green);
      background: transparent;
      color: var(--hornet-green);
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .back-button:hover {
      background: var(--hornet-green);
      color: var(--hornet-gold);
    }

    /* Loading progress bar */
    .loading-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.95);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 10000;
      gap: 2rem;
    }

    .loading-container.hidden {
      display: none;
    }

    .loading-title {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--hornet-green);
      text-align: center;
    }

    .loading-subtitle {
      font-size: 1rem;
      color: var(--text-secondary);
      text-align: center;
      margin-top: 0.5rem;
    }

    .progress-bar-container {
      width: 80%;
      max-width: 500px;
      height: 8px;
      background: #e9ecef;
      border-radius: 4px;
      overflow: hidden;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    .progress-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--hornet-green) 0%, var(--hornet-gold) 100%);
      border-radius: 4px;
      transition: width 0.3s ease;
      width: 0%;
    }

    .loading-percentage {
      font-size: 2rem;
      font-weight: 800;
      color: var(--hornet-green);
      margin-top: 1rem;
    }
  </style>
</head>
<body>
  <!-- Loading Progress Bar -->
  <div id="loadingContainer" class="loading-container">
    <div class="loading-title">üêù Loading Athlete Data</div>
    <div class="loading-subtitle" id="loadingMessage">Initializing...</div>
    <div class="progress-bar-container">
      <div id="progressBarFill" class="progress-bar-fill"></div>
    </div>
    <div class="loading-percentage" id="loadingPercentage">0%</div>
  </div>

  <main class="main-content">
    <!-- Top Controls -->
    <div class="top-controls">
      <button class="back-button" onclick="window.location.href='index.html'">
        ‚Üê Back to Home
      </button>
    </div>

    <h1 id="progressTitle" style="text-align: center; font-size: 2.5rem; font-weight: 800; color: var(--hornet-green); margin-bottom: 2rem;">üìà Athlete Progress</h1>

    <div class="progress-container">
    <div class="athlete-selector admin-only" id="athleteSelector" style="display: none;">
      <select id="athleteDropdown" class="athlete-dropdown">
        <option value="">Select an Athlete</option>
      </select>
    </div>

    <div id="progressContent" class="progress-content">
      <div class="stats-overview">
        <div class="stat-card">
          <div class="stat-label">Total Workouts</div>
          <div class="stat-value" id="totalWorkouts">0</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Hornet Rating</div>
          <div class="stat-value" id="overallRating">--</div>
        </div>
        <div class="stat-card">
          <div class="stat-label">Last Workout</div>
          <div class="stat-value" id="lastWorkout">--</div>
        </div>
      </div>

      <div class="progress-section">
        <div class="section-header">
          <span class="section-icon">üìä</span>
          <h2 class="section-title">Exercise Progress</h2>
        </div>
        <div id="allExercisesProgress" class="exercise-grid"></div>
      </div>
    </div>

    <div id="noData" class="no-data">
      Select an athlete to view their progress
    </div>
  </main>

  <!-- Hornet Animation Container -->
  <div id="hornetContainer" class="hornet-container"></div>

  <script src="script.js"></script>
  <script>
    const AUTH_HEADER = 'Bearer 31606b711ce9ef5a7b7d887dcbe60c6601f6691d7d3b9bab3f0eeb0ab9db';
    const ORG_ID = 7617;

    const EXERCISE_CONFIG = {
      'Back Squat': { body_segment: 'LOWER', movement_pattern: 'SQUAT' },
      'Front Squat': { body_segment: 'LOWER', movement_pattern: 'SQUAT' },
      'Trap Bar Deadlift': { body_segment: 'LOWER', movement_pattern: 'DEADLIFT' },
      'Bar RDL': { body_segment: 'LOWER', movement_pattern: 'DEADLIFT' },
      'Trap Bar Jump': { body_segment: 'LOWER', movement_pattern: 'JUMP' },
      'Bench Press': { body_segment: 'UPPER', movement_pattern: 'PRESS' },
      'Vertical Jump': { body_segment: 'LOWER', movement_pattern: 'JUMP' }
    };

    let allUsers = [];
    let allExercises = {};
    let allSets = [];

    // Unit conversion constants
    const M_PER_IN = 0.0254;
    const KG_PER_LBS = 0.453592;
    const N_PER_LBS = 4.44822;

    // Convert mean power from (in * lbs / s) to watts
    function convertMeanPowerToWatts(meanPowerInLbsInS) {
      if (meanPowerInLbsInS == null) return null;
      return M_PER_IN * N_PER_LBS * meanPowerInLbsInS;
    }

    // Convert peak power from (in^2 * lbs) / sec^3 to watts
    function convertPeakPowerToWatts(peakPowerPerMassZ, weightLbs) {
      if (peakPowerPerMassZ == null || weightLbs == null) return null;
      return (M_PER_IN * M_PER_IN) * KG_PER_LBS * peakPowerPerMassZ * weightLbs;
    }

    // Filter out ghost reps from a set's reps array
    function getValidReps(set) {
      if (!set.reps || set.reps.length === 0) return [];
      
      // If there are ghost rep indices, filter them out
      if (set.error && set.error.ghost_rep_indices && set.error.ghost_rep_indices.length > 0) {
        const ghostIndices = new Set(set.error.ghost_rep_indices);
        return set.reps.filter((rep, index) => !ghostIndices.has(index));
      }
      
      // No ghost reps, return all reps
      return set.reps;
    }

    let progressInterval = null;

    function updateProgress(percent, message) {
      document.getElementById('progressBarFill').style.width = `${percent}%`;
      document.getElementById('loadingPercentage').textContent = `${Math.round(percent)}%`;
      document.getElementById('loadingMessage').textContent = message;
    }

    function startContinuousProgress(duration, message) {
      return new Promise(resolve => {
        let startTime = Date.now();
        let currentPercent = 0;
        
        updateProgress(0, message);
        
        progressInterval = setInterval(() => {
          const elapsed = Date.now() - startTime;
          currentPercent = Math.min(99, (elapsed / duration) * 100);
          updateProgress(currentPercent, message);
          
          if (currentPercent >= 99) {
            clearInterval(progressInterval);
            resolve();
          }
        }, 50);
      });
    }

    function stopProgressAndComplete(message) {
      if (progressInterval) {
        clearInterval(progressInterval);
        progressInterval = null;
      }
      updateProgress(100, message);
    }

    function hideLoading() {
      document.getElementById('loadingContainer').classList.add('hidden');
    }

    async function loadData() {
      try {
        // Start continuous 30-second progress animation
        const progressPromise = startContinuousProgress(30000, 'Loading data...');
        
        // Load ALL users (active + inactive) for proper rating calculations
        allUsers = await loadAllUsers();
        console.log('Loaded users');

        const exercises = await fetchExercises();
        allExercises = {};
        exercises.forEach(ex => {
          allExercises[ex.id] = ex.name;
        });
        console.log('Loaded exercises');

        allSets = await fetchAllSets(exercises);
        console.log('Loaded sets');

        // Calculate ratings for all users (same as Hornet Ratings page)
        calculateAllRatings();
        console.log('Calculated ratings');

        // Data is ready - jump to 100%
        stopProgressAndComplete('Data ready!');
        populateAthleteDropdown();
        
        await new Promise(resolve => setTimeout(resolve, 500));
        hideLoading();
      } catch (error) {
        console.error('Error loading data:', error);
        stopProgressAndComplete('Error loading data. Please refresh.');
      }
    }

    async function loadAllUsers() {
      try {
        let allUsers = [];
        
        // Load active users
        const activeUsers = await fetchUsersByActiveStatus(true);
        allUsers = allUsers.concat(activeUsers);
        
        // Load inactive users  
        const inactiveUsers = await fetchUsersByActiveStatus(false);
        allUsers = allUsers.concat(inactiveUsers);
        
        // Sort by name
        allUsers.sort((a, b) => {
          const nameA = `${a.first_name} ${a.last_name}`.toLowerCase();
          const nameB = `${b.first_name} ${b.last_name}`.toLowerCase();
          return nameA.localeCompare(nameB);
        });
        
        console.log(`Loaded ${allUsers.length} total users (active + inactive)`);
        return allUsers;
      } catch (error) {
        console.error('Error loading users:', error);
        return [];
      }
    }

    async function fetchUsersByActiveStatus(isActive) {
      try {
        let users = [];
        let hasMore = true;
        let nextToken = null;
        const limit = 500;
        
        while (hasMore) {
          const body = {
            limit: limit,
            next_token: nextToken,
            group_id: ORG_ID,
            active: isActive
          };

          const response = await fetch('https://api.perch.fit/v2/users', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': AUTH_HEADER,
              'accept': 'application/json'
            },
            body: JSON.stringify(body)
          });

          if (!response.ok) {
            console.warn(`${isActive ? 'Active' : 'Inactive'} users fetch failed ${response.status}`);
            break;
          }
          
          const data = await response.json();
          const batchUsers = data.data || [];
          users = users.concat(batchUsers);
          
          if (data.truncated && data.next_token) {
            nextToken = data.next_token;
          } else {
            hasMore = false;
          }
        }
        
        return users;
      } catch (error) {
        console.error(`Error loading ${isActive ? 'active' : 'inactive'} users:`, error);
        return [];
      }
    }

    async function fetchExercises() {
      try {
        const response = await fetch('https://api.perch.fit/v3/exercises', {
          headers: { 'Authorization': AUTH_HEADER, 'accept': 'application/json' }
        });
        
        if (response.ok) {
          const data = await response.json();
          const exercises = data.data || [];
          
          // Return ALL exercises, not just those in EXERCISE_CONFIG
          console.log(`Found ${exercises.length} total exercises`);
          return exercises.filter(ex => ex.name); // Only filter out exercises without names
        }
      } catch (error) {
        console.error('Error loading exercises:', error);
      }
      return [];
    }

    async function fetchAllSets(exercises) {
      try {
        let allSets = [];
        const endTime = Math.floor(Date.now() / 1000);
        const beginTime = 0; // Get all data from the beginning of time
        
        for (const exercise of exercises) {
          console.log(`Loading sets for ${exercise.name}...`);
          const sets = await fetchSetsForExercise(exercise.id, beginTime, endTime);
          const setsWithName = sets.map(set => ({
            ...set,
            exercise_name: exercise.name
          }));
          allSets = allSets.concat(setsWithName);
          console.log(`Loaded ${sets.length} sets for ${exercise.name}`);
        }
        
        console.log(`Total sets loaded: ${allSets.length}`);
        return allSets;
      } catch (error) {
        console.error('Error loading sets:', error);
        return [];
      }
    }

    async function fetchSetsForExercise(exerciseId, beginTime, endTime) {
      try {
        let sets = [];
        let nextToken = null;
        const limit = 1000;
        let hasMore = true;
        
        while (hasMore) {
          const body = {
            limit: limit,
            next_token: nextToken,
            group_id: ORG_ID,
            exercise_id: exerciseId,
            include_reps: true,
            untracked: 'EXCLUDE',
            begin_time: beginTime,
            end_time: endTime
          };
          
          const response = await fetch('https://api.perch.fit/v3/sets', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': AUTH_HEADER,
              'accept': 'application/json'
            },
            body: JSON.stringify(body)
          });
          
          if (!response.ok) {
            console.warn(`Failed to fetch sets for exercise ${exerciseId}`);
            break;
          }
          
          const data = await response.json();
          const batchSets = data.data || [];
          sets = sets.concat(batchSets);
          
          if (data.truncated && data.next_token) {
            nextToken = data.next_token;
          } else {
            hasMore = false;
          }
        }
        
        return sets;
      } catch (error) {
        console.error(`Error fetching sets for exercise ${exerciseId}:`, error);
        return [];
      }
    }

    function populateAthleteDropdown() {
      const session = getAthleteSession();
      const dropdown = document.getElementById('athleteDropdown');
      dropdown.innerHTML = '<option value="">Select an Athlete</option>';
      
      // Show controls only if admin
      if (session && session.isAdmin) {
        document.getElementById('athleteSelector').classList.remove('admin-only');
        document.getElementById('athleteSelector').style.display = 'flex';
      }
      
      // Only show active users in dropdown (but use all users for rating calculations)
      let activeUsers = allUsers.filter(user => user.active === true);
      
      // If not admin, only show the logged-in athlete
      if (session && !session.isAdmin) {
        activeUsers = activeUsers.filter(user => user.id === session.id);
      }
      
      activeUsers.forEach(user => {
        const option = document.createElement('option');
        option.value = user.id;
        const name = user.name || `${user.first_name || ''} ${user.last_name || ''}`.trim();
        option.textContent = name;
        dropdown.appendChild(option);
      });

      // Auto-select first athlete for better UX
      if (activeUsers.length > 0 && !dropdown.value) {
        dropdown.value = activeUsers[0].id;
        displayAthleteProgress(activeUsers[0].id);
      }

      dropdown.addEventListener('change', (e) => {
        const userId = parseInt(e.target.value);
        if (userId) {
          displayAthleteProgress(userId);
        } else {
          hideProgress();
        }
      });
    }

    function displayAthleteProgress(userId) {
      const athlete = allUsers.find(u => u.id === userId);
      if (!athlete) return;

      // Update title with athlete name
      const athleteName = athlete.name || `${athlete.first_name || ''} ${athlete.last_name || ''}`.trim();
      document.getElementById('progressTitle').textContent = `üìà ${athleteName} Athlete Progress`;

      document.getElementById('progressContent').classList.add('active');
      document.getElementById('noData').style.display = 'none';

      const athleteSets = allSets.filter(set => set.user_id === userId);
      
      // Calculate overview stats
      const uniqueDates = new Set(athleteSets.map(s => new Date(s.created_at * 1000).toDateString()));
      const totalWorkouts = uniqueDates.size;
      const lastWorkout = athleteSets.length > 0 
        ? new Date(Math.max(...athleteSets.map(s => s.created_at * 1000))).toLocaleDateString()
        : '--';
      
      document.getElementById('totalWorkouts').textContent = totalWorkouts;
      document.getElementById('lastWorkout').textContent = lastWorkout;

      // Get athlete's pre-calculated Hornet Rating
      const rating = athlete.overall_rating || '--';
      document.getElementById('overallRating').textContent = rating;

      // Process exercise data
      const exerciseProgress = calculateExerciseProgress(athleteSets);
      console.log('Exercise progress calculated:', exerciseProgress);
      
      // Display all exercise progress
      displayAllExercisesProgress(exerciseProgress);
    }

    // Calculate ratings for all users (same logic as Hornet Ratings page)
    function calculateAllRatings() {
      // First calculate metrics for all users
      const athleteMetrics = allUsers.map(user => {
        const userSets = allSets.filter(set => set.user_id === user.id);
        return calculateSingleAthleteMetrics(user, userSets);
      });

      const genders = ['male', 'female'];
      // Use all exercises for progress tracking
      const exercises = EXERCISES_CONFIG.map(ex => ex.name);
      const metrics = ['strength', 'power'];
      
      // Store rating scales for each gender/exercise/metric combination
      const ratingScales = {};
      
      // Calculate min/max/step for each exercise/metric within each gender
      genders.forEach(gender => {
        ratingScales[gender] = {};
        const genderAthletes = athleteMetrics.filter(a => a.gender === gender);
        
        exercises.forEach(exercise => {
          ratingScales[gender][exercise] = {};
          
          metrics.forEach(metric => {
            const values = genderAthletes
              .map(a => a.exercises[exercise]?.[metric])
              .filter(v => v !== null && v !== undefined);
            
            if (values.length === 0) {
              ratingScales[gender][exercise][metric] = null;
              return;
            }
            
            const minValue = Math.min(...values);
            const maxValue = Math.max(...values);
            const range = maxValue - minValue;
            const step = range > 0 ? range / 50 : 1;
            
            ratingScales[gender][exercise][metric] = { minValue, maxValue, step };
          });
        });
        
        // Add Vertical Jump rating scale
        ratingScales[gender]['Vertical Jump'] = {};
        const jumpHeights = genderAthletes
          .map(a => a.exercises['Vertical Jump']?.jumpHeight)
          .filter(v => v !== null && v !== undefined);
        
        if (jumpHeights.length > 0) {
          const minValue = Math.min(...jumpHeights);
          const maxValue = Math.max(...jumpHeights);
          const range = maxValue - minValue;
          const step = range > 0 ? range / 50 : 1;
          ratingScales[gender]['Vertical Jump']['jumpHeight'] = { minValue, maxValue, step };
        } else {
          ratingScales[gender]['Vertical Jump']['jumpHeight'] = null;
        }
      });
      
      // Calculate individual ratings for each athlete and store them on the user object
      athleteMetrics.forEach(athleteMetric => {
        const athlete = allUsers.find(u => u.id === athleteMetric.user_id);
        if (!athlete) return;
        
        const gender = athleteMetric.gender;
        
        // Store individual exercise ratings
        athlete.exerciseRatings = {};
        
        exercises.forEach(exercise => {
          athlete.exerciseRatings[exercise] = {};
          
          metrics.forEach(metric => {
            const value = athleteMetric.exercises[exercise]?.[metric];
            const scale = ratingScales[gender]?.[exercise]?.[metric];
            
            if (value !== null && value !== undefined && scale) {
              const { minValue, step } = scale;
              const rawRating = 49 + ((value - minValue) / step);
              athlete.exerciseRatings[exercise][metric] = Math.max(49, Math.min(99, Math.round(rawRating)));
            } else {
              athlete.exerciseRatings[exercise][metric] = null;
            }
          });
        });
        
        // Add Vertical Jump rating
        athlete.exerciseRatings['Vertical Jump'] = {};
        const jumpHeight = athleteMetric.exercises['Vertical Jump']?.jumpHeight;
        const jumpScale = ratingScales[gender]?.['Vertical Jump']?.['jumpHeight'];
        
        if (jumpHeight !== null && jumpHeight !== undefined && jumpScale) {
          const { minValue, step } = jumpScale;
          const rawRating = 49 + ((jumpHeight - minValue) / step);
          athlete.exerciseRatings['Vertical Jump']['jumpHeight'] = Math.max(49, Math.min(99, Math.round(rawRating)));
        } else {
          athlete.exerciseRatings['Vertical Jump']['jumpHeight'] = null;
        }
        
        // Calculate category ratings
        const lowerBodyExercises = ['Back Squat', 'Front Squat', 'Trap Bar Deadlift', 'Bar RDL', 'Trap Bar Jump'];
        
        const lowerStrengthRatings = ['Back Squat', 'Front Squat', 'Trap Bar Deadlift', 'Bar RDL']
          .map(ex => athlete.exerciseRatings[ex]?.strength)
          .filter(r => r !== null && r !== undefined);
        athlete.lower_body_strength_rating = lowerStrengthRatings.length > 0
          ? Math.round(lowerStrengthRatings.reduce((sum, r) => sum + r, 0) / lowerStrengthRatings.length)
          : 49;
        
        const lowerPowerRatings = lowerBodyExercises
          .map(ex => athlete.exerciseRatings[ex]?.power)
          .filter(r => r !== null && r !== undefined);
        athlete.lower_body_power_rating = lowerPowerRatings.length > 0
          ? Math.round(lowerPowerRatings.reduce((sum, r) => sum + r, 0) / lowerPowerRatings.length)
          : 49;
        
        athlete.upper_body_strength_rating = athlete.exerciseRatings['Bench Press']?.strength || 49;
        athlete.upper_body_power_rating = athlete.exerciseRatings['Bench Press']?.power || 49;
        athlete.jump_rating = athlete.exerciseRatings['Vertical Jump']?.jumpHeight || 49;
        
        // Calculate overall rating (average of all 5 category ratings)
        const categoryRatings = [
          athlete.lower_body_strength_rating,
          athlete.lower_body_power_rating,
          athlete.upper_body_strength_rating,
          athlete.upper_body_power_rating,
          athlete.jump_rating
        ].filter(r => r !== null && r !== undefined && r !== 49);
        
        athlete.overall_rating = categoryRatings.length > 0 
          ? Math.round(categoryRatings.reduce((sum, r) => sum + r, 0) / categoryRatings.length)
          : 49;
      });
    }

    async function fetchAthleteRating(userId) {
      try {
        // This function is no longer used - ratings are pre-calculated
        const athlete = allUsers.find(u => u.id === userId);
        if (!athlete) return null;

        // Get all users for rating scale calculation
        const athleteSets = allSets.filter(set => set.user_id === userId);
        
        // Calculate metrics for this athlete
        const athleteMetrics = calculateSingleAthleteMetrics(athlete, athleteSets);
        
        // Calculate rating using all users as reference
        const rating = await calculateAthleteRating(athleteMetrics, athlete.gender);
        
        return rating;
      } catch (error) {
        console.error('Error fetching athlete rating:', error);
        return null;
      }
    }

    function calculateSingleAthleteMetrics(user, sets) {
      const metrics = {
        user_id: user.id,
        name: user.name || `${user.first_name || ''} ${user.last_name || ''}`.trim(),
        gender: user.gender ? user.gender.toLowerCase() : 'unknown',
        exercises: {
          'Back Squat': { strength: null, power: null },
          'Front Squat': { strength: null, power: null },
          'Trap Bar Deadlift': { strength: null, power: null },
          'Bar RDL': { strength: null, power: null },
          'Trap Bar Jump': { strength: null, power: null },
          'Bench Press': { strength: null, power: null },
          'Vertical Jump': { jumpHeight: null }
        }
      };

      sets.forEach(set => {
        const exerciseName = set.exercise_name;
        const exerciseConfig = EXERCISE_CONFIG[exerciseName];
        if (!exerciseConfig) return;

        if (exerciseConfig.movement_pattern === 'VERTICAL_JUMP') {
          if (set.max_jump_height && (!metrics.exercises[exerciseName].jumpHeight || set.max_jump_height > metrics.exercises[exerciseName].jumpHeight)) {
            metrics.exercises[exerciseName].jumpHeight = set.max_jump_height;
          }
          return;
        }

        // Get only valid reps (excluding ghost reps)
        const validReps = getValidReps(set);
        if (validReps.length === 0 || !set.weight || set.weight <= 0) return;

        validReps.forEach(rep => {
          if (!metrics.exercises[exerciseName].strength || set.weight > metrics.exercises[exerciseName].strength) {
            metrics.exercises[exerciseName].strength = set.weight;
          }

          // Calculate power based on exercise type
          let power = null;
          if (exerciseConfig.movement_pattern === 'JUMP') {
            // Use peak power for jumps
            if (rep.concentric_peak_power_per_mass_z) {
              power = convertPeakPowerToWatts(rep.concentric_peak_power_per_mass_z, set.weight);
            }
          } else {
            // Use mean power for other exercises
            if (rep.concentric_mean_velocity_z) {
              power = convertMeanPowerToWatts(rep.concentric_mean_velocity_z * set.weight);
            }
          }
          
          // Only count power if it's greater than 0
          if (power && power > 0 && (!metrics.exercises[exerciseName].power || power > metrics.exercises[exerciseName].power)) {
            metrics.exercises[exerciseName].power = power;
          }
        });
      });

      return metrics;
    }

    function calculateExerciseProgress(athleteSets) {
      const progress = {};

      // Group sets by date for each exercise
      const sessionsByExercise = {};
      
      athleteSets.forEach(set => {
        const exerciseName = set.exercise_name;
        if (!exerciseName) return;

        // Initialize progress for this exercise if not already done
        if (!progress[exerciseName]) {
          progress[exerciseName] = {
            sessions: [], // Array of session objects with date, weight, meanPower, peakPower
            best: { weight: null, meanPower: null, peakPower: null, height: null },
            first: { weight: null, meanPower: null, peakPower: null, height: null }
          };
        }

        if (!sessionsByExercise[exerciseName]) {
          sessionsByExercise[exerciseName] = {};
        }

        const dateKey = new Date(set.created_at * 1000).toLocaleDateString();
        
        if (!sessionsByExercise[exerciseName][dateKey]) {
          sessionsByExercise[exerciseName][dateKey] = {
            date: new Date(set.created_at * 1000),
            sets: []
          };
        }
        
        sessionsByExercise[exerciseName][dateKey].sets.push(set);
      });

      // Process each exercise's sessions
      Object.keys(sessionsByExercise).forEach(exerciseName => {
        const sessions = Object.values(sessionsByExercise[exerciseName]);
        sessions.sort((a, b) => a.date - b.date);

        sessions.forEach(session => {
          let sessionWeight = 0;
          let sessionMeanPower = 0;
          let sessionPeakPower = 0;
          let sessionHeight = 0;

          if (exerciseName === 'Vertical Jump') {
            // For vertical jump, use max_jump_height from the session
            session.sets.forEach(set => {
              if (set.max_jump_height && set.max_jump_height > sessionHeight) {
                sessionHeight = set.max_jump_height;
              }
            });

            if (sessionHeight > 0) {
              progress[exerciseName].sessions.push({
                date: session.date,
                height: sessionHeight
              });

              if (!progress[exerciseName].first.height) {
                progress[exerciseName].first.height = sessionHeight;
              }
              if (!progress[exerciseName].best.height || sessionHeight > progress[exerciseName].best.height) {
                progress[exerciseName].best.height = sessionHeight;
              }
            }
          } else {
            // For other exercises, find best weight, mean power, and peak power in the session
            session.sets.forEach(set => {
              if (!set.reps || set.reps.length === 0 || !set.weight || set.weight <= 0) return;

              if (set.weight > sessionWeight) {
                sessionWeight = set.weight;
              }

              set.reps.forEach(rep => {
                const meanPower = rep.concentric_mean_velocity_z ? 
                  convertMeanPowerToWatts(rep.concentric_mean_velocity_z * set.weight) : 0;
                const peakPower = rep.concentric_peak_power_per_mass_z ?
                  convertPeakPowerToWatts(rep.concentric_peak_power_per_mass_z, set.weight) : 0;

                if (meanPower > sessionMeanPower) sessionMeanPower = meanPower;
                if (peakPower > sessionPeakPower) sessionPeakPower = peakPower;
              });
            });

            if (sessionWeight > 0) {
              progress[exerciseName].sessions.push({
                date: session.date,
                weight: sessionWeight,
                meanPower: sessionMeanPower || null,
                peakPower: sessionPeakPower || null
              });

              // Track first values
              if (!progress[exerciseName].first.weight) {
                progress[exerciseName].first.weight = sessionWeight;
                progress[exerciseName].first.meanPower = sessionMeanPower || null;
                progress[exerciseName].first.peakPower = sessionPeakPower || null;
              }

              // Track best values
              if (!progress[exerciseName].best.weight || sessionWeight > progress[exerciseName].best.weight) {
                progress[exerciseName].best.weight = sessionWeight;
              }
              if (sessionMeanPower && (!progress[exerciseName].best.meanPower || sessionMeanPower > progress[exerciseName].best.meanPower)) {
                progress[exerciseName].best.meanPower = sessionMeanPower;
              }
              if (sessionPeakPower && (!progress[exerciseName].best.peakPower || sessionPeakPower > progress[exerciseName].best.peakPower)) {
                progress[exerciseName].best.peakPower = sessionPeakPower;
              }
            }
          }
        });
      });

      return progress;
    }

    // Convert mean power from (in * lbs / s) to watts
    function convertMeanPowerToWatts(meanPowerInLbsInS) {
      if (meanPowerInLbsInS == null) return null;
      const M_PER_IN = 0.0254;
      const N_PER_LBS = 4.44822;
      return M_PER_IN * N_PER_LBS * meanPowerInLbsInS;
    }

    // Convert peak power from (in^2 * lbs) / sec^3 to watts
    function convertPeakPowerToWatts(peakPowerPerMassZ, weightLbs) {
      if (peakPowerPerMassZ == null || weightLbs == null) return null;
      const M_PER_IN = 0.0254;
      const KG_PER_LBS = 0.453592;
      return (M_PER_IN * M_PER_IN) * KG_PER_LBS * peakPowerPerMassZ * weightLbs;
    }

    function displayAllExercisesProgress(progress) {
      const container = document.getElementById('allExercisesProgress');
      container.innerHTML = '';

      console.log('displayAllExercisesProgress called with:', progress);

      // Get all exercises that have data
      const exercisesWithData = Object.keys(progress).filter(exerciseName => {
        const data = progress[exerciseName];
        return data.sessions && data.sessions.length > 0;
      });

      console.log(`Found ${exercisesWithData.length} exercises with data:`, exercisesWithData);

      if (exercisesWithData.length === 0) {
        container.innerHTML = '<div class="no-data">No exercise data available</div>';
        return;
      }

      // Sort exercises alphabetically
      exercisesWithData.sort();

      // Display each exercise
      exercisesWithData.forEach(exerciseName => {
        const data = progress[exerciseName];
        const isJump = exerciseName === 'Vertical Jump';
        
        // Calculate improvement based on exercise type
        let improvement = 0;
        let bestLabel = '';
        let bestValue = '';
        
        if (isJump) {
          improvement = data.first.height && data.best.height
            ? ((data.best.height - data.first.height) / data.first.height * 100).toFixed(1)
            : 0;
          bestLabel = 'Best Height';
          bestValue = data.best.height ? data.best.height.toFixed(1) + ' in' : 'N/A';
        } else {
          // Use weight for improvement calculation
          improvement = data.first.weight && data.best.weight
            ? ((data.best.weight - data.first.weight) / data.first.weight * 100).toFixed(1)
            : 0;
          bestLabel = 'Best Weight';
          bestValue = data.best.weight ? data.best.weight.toFixed(1) + ' lbs' : 'N/A';
        }

        const card = document.createElement('div');
        card.className = 'exercise-card';
        const chartId = `chart-${exerciseName.replace(/\s+/g, '-').toLowerCase()}`;
        card.innerHTML = `
          <div class="exercise-name">${exerciseName}</div>
          <div class="chart-container">
            <canvas id="${chartId}"></canvas>
          </div>
          <div class="metric-summary">
            <div class="metric-stat">
              <div class="metric-stat-label">${bestLabel}</div>
              <div class="metric-stat-value">${bestValue}</div>
            </div>
            <div class="metric-stat">
              <div class="metric-stat-label">Sessions</div>
              <div class="metric-stat-value">${data.sessions.length}</div>
            </div>
            <div class="metric-stat">
              <div class="metric-stat-label">Improvement</div>
              <div class="metric-stat-value ${improvement > 0 ? 'improvement' : improvement < 0 ? 'decline' : ''}">${improvement > 0 ? '+' : ''}${improvement}%</div>
            </div>
          </div>
        `;
        container.appendChild(card);

        // Create the chart
        createExerciseChart(chartId, data, exerciseName, isJump);
      });
    }

    function createExerciseChart(canvasId, data, exerciseName, isJump) {
      const ctx = document.getElementById(canvasId);
      if (!ctx) return;

      const dates = data.sessions.map(s => s.date.toLocaleDateString());
      
      const datasets = [];

      if (isJump) {
        // For vertical jump, only show height
        datasets.push({
          label: 'Height (in)',
          data: data.sessions.map(s => s.height),
          borderColor: '#00563B',
          backgroundColor: 'rgba(0, 86, 59, 0.1)',
          borderWidth: 2,
          tension: 0.4,
          fill: true
        });
      } else {
        // For other exercises, show weight, mean power, and peak power
        datasets.push({
          label: 'Weight (lbs)',
          data: data.sessions.map(s => s.weight),
          borderColor: '#00563B',
          backgroundColor: 'rgba(0, 86, 59, 0.1)',
          borderWidth: 2,
          tension: 0.4,
          yAxisID: 'y-weight'
        });

        if (data.sessions.some(s => s.meanPower)) {
          datasets.push({
            label: 'Mean Power (W)',
            data: data.sessions.map(s => s.meanPower),
            borderColor: '#FFC72C',
            backgroundColor: 'rgba(255, 199, 44, 0.1)',
            borderWidth: 2,
            tension: 0.4,
            yAxisID: 'y-power'
          });
        }

        if (data.sessions.some(s => s.peakPower)) {
          datasets.push({
            label: 'Peak Power (W)',
            data: data.sessions.map(s => s.peakPower),
            borderColor: '#FF6B35',
            backgroundColor: 'rgba(255, 107, 53, 0.1)',
            borderWidth: 2,
            tension: 0.4,
            yAxisID: 'y-power'
          });
        }
      }

      new Chart(ctx, {
        type: 'line',
        data: {
          labels: dates,
          datasets: datasets
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: 'index',
            intersect: false,
          },
          plugins: {
            legend: {
              display: true,
              position: 'top',
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  let label = context.dataset.label || '';
                  if (label) {
                    label += ': ';
                  }
                  if (context.parsed.y !== null) {
                    label += context.parsed.y.toFixed(1);
                  }
                  return label;
                }
              }
            }
          },
          scales: isJump ? {
            y: {
              beginAtZero: false,
              title: {
                display: true,
                text: 'Height (in)'
              }
            }
          } : {
            'y-weight': {
              type: 'linear',
              display: true,
              position: 'left',
              title: {
                display: true,
                text: 'Weight (lbs)'
              },
              beginAtZero: false
            },
            'y-power': {
              type: 'linear',
              display: datasets.length > 1,
              position: 'right',
              title: {
                display: true,
                text: 'Power (W)'
              },
              beginAtZero: false,
              grid: {
                drawOnChartArea: false,
              }
            }
          }
        }
      });
    }

    function hideProgress() {
      document.getElementById('progressContent').classList.remove('active');
      document.getElementById('noData').style.display = 'block';
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      // Check authentication first
      if (!requireAthleteAuth()) {
        return; // Will redirect to login
      }
      loadData();
    });
  </script>
</body>
</html>
