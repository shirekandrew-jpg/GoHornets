<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hornet Ratings</title>
  <link rel="icon" type="image/svg+xml" href="favicon.svg">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
  <script src="auth.js"></script>
  <style>
    /* Rating card styling */
    .ratings-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem;
    }

    .athlete-selector {
      display: flex;
      justify-content: center;
      margin-bottom: 2rem;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .athlete-dropdown {
      padding: 0.75rem 1.5rem;
      border-radius: 12px;
      border: 2px solid var(--hornet-green);
      background: white;
      color: var(--text-primary);
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      min-width: 200px;
    }

    .gender-selector {
      display: flex;
      justify-content: center;
      margin-bottom: 2rem;
      gap: 1rem;
    }

    .gender-tab {
      padding: 0.75rem 2rem;
      border-radius: 12px;
      border: 2px solid var(--hornet-green);
      background: transparent;
      color: var(--hornet-green);
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .gender-tab.active {
      background: var(--hornet-green);
      color: var(--hornet-gold);
    }

    .rating-cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 2rem;
      margin-bottom: 3rem;
    }

    .rating-card {
      background: linear-gradient(135deg, white 0%, #f8f9fa 100%);
      border-radius: 16px;
      padding: 2rem;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      border: 1px solid var(--border-light);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    .rating-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
    }

    .rating-header {
      display: flex;
      align-items: center;
      margin-bottom: 1.5rem;
    }

    .rating-icon {
      font-size: 2rem;
      margin-right: 1rem;
    }

    .rating-title {
      font-size: 1.2rem;
      font-weight: 700;
      color: var(--hornet-green);
      margin: 0;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .rating-score {
      font-size: 3rem;
      font-weight: 800;
      color: var(--hornet-green);
      margin: 1rem 0;
      text-align: center;
    }

    .rating-bar {
      width: 100%;
      height: 12px;
      background: #e9ecef;
      border-radius: 6px;
      overflow: hidden;
      margin: 1rem 0;
    }

    .rating-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--hornet-green) 0%, var(--hornet-gold) 100%);
      border-radius: 6px;
      transition: width 0.8s ease;
    }

    .rating-details {
      font-size: 0.9rem;
      color: var(--text-secondary);
      text-align: center;
      margin-top: 1rem;
    }

    .overall-rating {
      background: linear-gradient(135deg, var(--hornet-green) 0%, var(--hornet-green-light) 100%);
      color: white;
      padding: 3rem 2rem;
      border-radius: 20px;
      text-align: center;
      margin-bottom: 3rem;
      box-shadow: 0 15px 40px rgba(0, 0, 0, 0.2);
    }

    .overall-score {
      font-size: 4rem;
      font-weight: 900;
      margin-bottom: 1rem;
    }

    .overall-title {
      font-size: 1.5rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .loading {
      text-align: center;
      padding: 3rem;
      color: var(--text-secondary);
      font-style: italic;
    }

    .error {
      text-align: center;
      padding: 2rem;
      color: #dc3545;
      background: #f8d7da;
      border-radius: 12px;
      margin: 1rem 0;
    }

    .back-button {
      padding: 0.5rem 1rem;
      border-radius: 8px;
      border: 2px solid var(--hornet-green);
      background: transparent;
      color: var(--hornet-green);
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 2rem;
    }

    .back-button:hover {
      background: var(--hornet-green);
      color: var(--hornet-gold);
    }

    /* Loading progress bar */
    .loading-container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.95);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 10000;
      gap: 2rem;
    }

    .loading-container.hidden {
      display: none;
    }

    .loading-title {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--hornet-green);
      text-align: center;
    }

    .loading-subtitle {
      font-size: 1rem;
      color: var(--text-secondary);
      text-align: center;
      margin-top: 0.5rem;
    }

    .progress-bar-container {
      width: 80%;
      max-width: 500px;
      height: 8px;
      background: #e9ecef;
      border-radius: 4px;
      overflow: hidden;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    .progress-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--hornet-green) 0%, var(--hornet-gold) 100%);
      border-radius: 4px;
      transition: width 0.3s ease;
      width: 0%;
    }

    .loading-percentage {
      font-size: 2rem;
      font-weight: 800;
      color: var(--hornet-green);
      margin-top: 1rem;
    }

    /* Responsive design */
    @media (max-width: 768px) {
      .ratings-container {
        padding: 1rem;
      }

      .rating-cards {
        grid-template-columns: 1fr;
        gap: 1rem;
      }

      .athlete-selector {
        flex-direction: column;
        align-items: center;
      }

      .overall-score {
        font-size: 3rem;
      }
    }
  </style>
</head>

<body>
  <!-- Loading Progress Bar -->
  <div id="loadingContainer" class="loading-container">
    <div class="loading-title">üêù Calculating Hornet Ratings</div>
    <div class="loading-subtitle" id="loadingMessage">Initializing...</div>
    <div class="progress-bar-container">
      <div id="progressBarFill" class="progress-bar-fill"></div>
    </div>
    <div class="loading-percentage" id="loadingPercentage">0%</div>
  </div>

  <main class="main-content">
    <!-- Top Controls -->
    <div class="top-controls">
      <button class="back-button" onclick="navigateWithHornets('index.html')">
        ‚Üê Back to Home
      </button>
    </div>

    <div class="ratings-container">

      <!-- Gender Selection -->
      <div class="gender-selector">
        <button class="gender-tab active" data-gender="male" onclick="switchGender('male')">
          Male Athletes
        </button>
        <button class="gender-tab" data-gender="female" onclick="switchGender('female')">
          Female Athletes
        </button>
      </div>

      <!-- Athlete Selection -->
      <div class="athlete-selector">
        <select class="athlete-dropdown" id="athleteSelector" onchange="selectAthlete()">
          <option value="">Select an athlete...</option>
        </select>
      </div>

      <!-- Loading/Error States -->
      <div id="loadingState" class="loading">Loading athletes and calculating ratings...</div>
      <div id="errorState" class="error" style="display: none;"></div>

      <!-- Rating Display -->
      <div id="ratingDisplay" style="display: none;">
        <!-- Overall Rating -->
        <div class="overall-rating">
          <div class="overall-score" id="overallScore">--</div>
          <div class="overall-title">Overall Hornet Rating</div>
        </div>

        <!-- Individual Rating Cards -->
        <div class="rating-cards">
          <!-- Lower Body Strength -->
          <div class="rating-card">
            <div class="rating-header">
              <span class="rating-icon">üî®</span>
              <h3 class="rating-title">Lower Body Strength</h3>
            </div>
            <div class="rating-score" id="lowerStrengthScore">--</div>
            <div class="rating-bar">
              <div class="rating-fill" id="lowerStrengthBar" style="width: 0%"></div>
            </div>
            <div class="rating-details" id="lowerStrengthDetails">Based on best weight from squats and deadlifts</div>
          </div>

          <!-- Lower Body Power -->
          <div class="rating-card">
            <div class="rating-header">
              <span class="rating-icon">‚ö°</span>
              <h3 class="rating-title">Lower Body Power</h3>
            </div>
            <div class="rating-score" id="lowerPowerScore">--</div>
            <div class="rating-bar">
              <div class="rating-fill" id="lowerPowerBar" style="width: 0%"></div>
            </div>
            <div class="rating-details" id="lowerPowerDetails">Based on best power from jumps and lifts</div>
          </div>

          <!-- Upper Body Strength -->
          <div class="rating-card">
            <div class="rating-header">
              <span class="rating-icon">üî®</span>
              <h3 class="rating-title">Upper Body Strength</h3>
            </div>
            <div class="rating-score" id="upperStrengthScore">--</div>
            <div class="rating-bar">
              <div class="rating-fill" id="upperStrengthBar" style="width: 0%"></div>
            </div>
            <div class="rating-details" id="upperStrengthDetails">Based on best weight from bench press</div>
          </div>

          <!-- Upper Body Power -->
          <div class="rating-card">
            <div class="rating-header">
              <span class="rating-icon">‚ö°</span>
              <h3 class="rating-title">Upper Body Power</h3>
            </div>
            <div class="rating-score" id="upperPowerScore">--</div>
            <div class="rating-bar">
              <div class="rating-fill" id="upperPowerBar" style="width: 0%"></div>
            </div>
            <div class="rating-details" id="upperPowerDetails">Based on best power from bench press</div>
          </div>

          <!-- Jump -->
          <div class="rating-card">
            <div class="rating-header">
              <span class="rating-icon">üöÄ</span>
              <h3 class="rating-title">Jump</h3>
            </div>
            <div class="rating-score" id="jumpScore">--</div>
            <div class="rating-bar">
              <div class="rating-fill" id="jumpBar" style="width: 0%"></div>
            </div>
            <div class="rating-details" id="jumpDetails">Based on max jump height</div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- Hornet Animation Container -->
  <div id="hornetContainer" class="hornet-container"></div>

  <script>
    // Hornet animation functions (copied from index.html)
    function navigateWithHornets(url) {
      if (url === '#') return;
      
      createHornetSwarm();
      
      setTimeout(() => {
        window.location.href = url;
      }, 1200);
    }

    function createHornetSwarm() {
      const container = document.getElementById('hornetContainer');
      container.innerHTML = '';
      
      for (let i = 0; i < 20; i++) {
        const hornet = document.createElement('div');
        hornet.className = 'hornet';
        
        hornet.innerHTML = `
          <div style="
            position: relative;
            width: 24px;
            height: 12px;
            background: linear-gradient(90deg, #1a1a1a 0%, #8b4513 20%, #ffd700 40%, #1a1a1a 60%, #8b4513 80%, #ffd700 100%);
            border-radius: 60% 40%;
            box-shadow: 
              0 0 4px rgba(255, 215, 0, 0.8),
              inset 0 1px 0 rgba(255, 255, 255, 0.4),
              inset 0 -1px 0 rgba(0, 0, 0, 0.3);
          ">
            <div style="
              position: absolute;
              top: -2px;
              left: 8px;
              width: 12px;
              height: 8px;
              background: radial-gradient(ellipse, rgba(255, 255, 255, 0.6) 0%, rgba(200, 220, 255, 0.3) 70%, transparent 100%);
              border-radius: 80% 20%;
              animation: wingFlap 0.08s infinite alternate;
              transform-origin: 20% 50%;
            "></div>
            <div style="
              position: absolute;
              top: -2px;
              left: 4px;
              width: 12px;
              height: 8px;
              background: radial-gradient(ellipse, rgba(255, 255, 255, 0.6) 0%, rgba(200, 220, 255, 0.3) 70%, transparent 100%);
              border-radius: 80% 20%;
              animation: wingFlap 0.08s infinite alternate-reverse;
              transform-origin: 80% 50%;
            "></div>
            <div style="
              position: absolute;
              top: 2px;
              left: 2px;
              width: 4px;
              height: 4px;
              background: #1a1a1a;
              border-radius: 50%;
              box-shadow: 8px 0 0 #1a1a1a;
            "></div>
          </div>
        `;
        
        const startY = Math.random() * window.innerHeight;
        const startX = -150;
        const duration = 3 + Math.random() * 3;
        const delay = Math.random() * 2;
        const size = 0.8 + Math.random() * 0.6;
        
        hornet.style.cssText = `
          position: fixed;
          left: ${startX}px;
          top: ${startY}px;
          z-index: 9999;
          pointer-events: none;
          animation: flyAcross ${duration}s cubic-bezier(0.25, 0.46, 0.45, 0.94) ${delay}s forwards;
          transform-origin: center;
          transform: scale(${size});
          filter: drop-shadow(2px 2px 6px rgba(0, 0, 0, 0.4));
        `;
        
        container.appendChild(hornet);
        
        setTimeout(() => {
          if (hornet.parentNode) {
            hornet.parentNode.removeChild(hornet);
          }
        }, (duration + delay + 1) * 1000);
      }
    }

    // Hornet Rating System Implementation
    const AUTH_HEADER = 'Bearer 31606b711ce9ef5a7b7d887dcbe60c6601f6691d7d3b9bab3f0eeb0ab9db';
    const ORG_ID = 7617;
    
    let allUsers = [];
    let allExercises = [];
    let allSets = [];
    let allRatings = {};
    let currentGender = 'male';
    let selectedAthlete = null;

    // Exercise mapping based on your requirements
    const EXERCISE_CONFIG = {
      'Back Squat': { body_segment: 'LOWER', movement_pattern: 'SQUAT' },
      'Front Squat': { body_segment: 'LOWER', movement_pattern: 'SQUAT' },
      'Trap Bar Deadlift': { body_segment: 'LOWER', movement_pattern: 'DEADLIFT' },
      'Bar RDL': { body_segment: 'LOWER', movement_pattern: 'DEADLIFT' },
      'Trap Bar Jump': { body_segment: 'LOWER', movement_pattern: 'JUMP' },
      'Bench Press': { body_segment: 'UPPER', movement_pattern: 'PRESS' },
      'Vertical Jump': { body_segment: 'LOWER', movement_pattern: 'VERTICAL_JUMP' }
    };

    // Unit conversion constants
    const M_PER_IN = 0.0254;
    const KG_PER_LBS = 0.453592;
    const N_PER_LBS = 4.44822;

    // Convert mean power from (in * lbs / s) to watts
    function convertMeanPowerToWatts(meanPowerInLbsInS) {
      if (meanPowerInLbsInS == null) return null;
      return M_PER_IN * N_PER_LBS * meanPowerInLbsInS;
    }

    // Convert peak power from (in^2 * lbs) / sec^3 to watts
    function convertPeakPowerToWatts(peakPowerPerMassZ, weightLbs) {
      if (peakPowerPerMassZ == null || weightLbs == null) return null;
      return (M_PER_IN * M_PER_IN) * KG_PER_LBS * peakPowerPerMassZ * weightLbs;
    }

    // Filter out ghost reps from a set's reps array
    function getValidReps(set) {
      if (!set.reps || set.reps.length === 0) return [];
      
      // If there are ghost rep indices, filter them out
      if (set.error && set.error.ghost_rep_indices && set.error.ghost_rep_indices.length > 0) {
        const ghostIndices = new Set(set.error.ghost_rep_indices);
        return set.reps.filter((rep, index) => !ghostIndices.has(index));
      }
      
      // No ghost reps, return all reps
      return set.reps;
    }

    // Load all users (both active and inactive for rating calculations)
    async function loadAllUsers() {
      try {
        let allUsers = [];
        
        // Load active users
        const activeUsers = await fetchUsersByActiveStatus(true);
        allUsers = allUsers.concat(activeUsers);
        
        // Load inactive users
        const inactiveUsers = await fetchUsersByActiveStatus(false);
        allUsers = allUsers.concat(inactiveUsers);
        
        console.log(`Loaded ${allUsers.length} total users (active + inactive)`);
        return allUsers;
      } catch (error) {
        console.error('Error loading users:', error);
        return [];
      }
    }

    async function fetchUsersByActiveStatus(isActive) {
      try {
        let users = [];
        let hasMore = true;
        let nextToken = null;
        const limit = 500;
        
        while (hasMore) {
          const body = {
            limit: limit,
            next_token: nextToken,
            group_id: ORG_ID,
            active: isActive
          };

          const response = await fetch('https://api.perch.fit/v2/users', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': AUTH_HEADER,
              'accept': 'application/json'
            },
            body: JSON.stringify(body)
          });

          if (!response.ok) {
            console.warn(`${isActive ? 'Active' : 'Inactive'} users fetch failed ${response.status}`);
            break;
          }
          
          const data = await response.json();
          const batchUsers = data.data || [];
          users = users.concat(batchUsers);
          
          if (data.truncated && data.next_token) {
            nextToken = data.next_token;
          } else {
            hasMore = false;
          }
        }
        
        return users;
      } catch (error) {
        console.error(`Error loading ${isActive ? 'active' : 'inactive'} users:`, error);
        return [];
      }
    }

    // Load exercises
    async function loadExercises() {
      try {
        const response = await fetch('https://api.perch.fit/v3/exercises', {
          headers: { 'Authorization': AUTH_HEADER, 'accept': 'application/json' }
        });
        
        if (response.ok) {
          const data = await response.json();
          const exercises = data.data || [];
          
          // Filter to only the exercises we care about
          const targetExercises = exercises.filter(ex => 
            ex.name && Object.keys(EXERCISE_CONFIG).some(targetName => 
              ex.name.toLowerCase().includes(targetName.toLowerCase())
            )
          );
          
          console.log(`Found ${targetExercises.length} target exercises for ratings`);
          return targetExercises;
        }
      } catch (error) {
        console.error('Error loading exercises:', error);
      }
      return [];
    }

    // Load sets data for rating exercises
    async function loadSetsData(exercises) {
      try {
        let allSets = [];
        const endTime = Math.floor(Date.now() / 1000);
        const beginTime = endTime - (5 * 365 * 24 * 60 * 60); // 5 years of data
        
        for (const exercise of exercises) {
          console.log(`Loading sets for ${exercise.name}...`);
          
          const sets = await fetchSetsForExercise(exercise.id, beginTime, endTime);
          const setsWithExerciseName = sets.map(set => ({
            ...set,
            exercise_name: exercise.name
          }));
          
          allSets = allSets.concat(setsWithExerciseName);
          console.log(`Loaded ${sets.length} sets for ${exercise.name}`);
        }
        
        console.log(`Total sets loaded: ${allSets.length}`);
        return allSets;
      } catch (error) {
        console.error('Error loading sets data:', error);
        return [];
      }
    }

    async function fetchSetsForExercise(exerciseId, beginTime, endTime) {
      try {
        let allSets = [];
        let nextToken = null;
        const limit = 1000;
        let hasMore = true;
        
        while (hasMore) {
          const body = {
            limit: limit,
            next_token: nextToken,
            group_id: ORG_ID,
            exercise_id: exerciseId,
            include_reps: true,
            untracked: 'EXCLUDE', // Only tracked sets
            begin_time: beginTime,
            end_time: endTime
          };
          
          const response = await fetch('https://api.perch.fit/v3/sets', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': AUTH_HEADER,
              'accept': 'application/json'
            },
            body: JSON.stringify(body)
          });
          
          if (!response.ok) {
            console.warn(`Failed to fetch sets for exercise ${exerciseId}: ${response.status}`);
            break;
          }
          
          const data = await response.json();
          const sets = data.data || [];
          allSets = allSets.concat(sets);
          
          if (data.truncated && data.next_token) {
            nextToken = data.next_token;
          } else {
            hasMore = false;
          }
        }
        
        return allSets;
      } catch (error) {
        console.error(`Error fetching sets for exercise ${exerciseId}:`, error);
        return [];
      }
    }

    // Calculate best rep metrics per athlete per exercise
    function calculateAthleteMetrics(users, sets) {
      const athleteMetrics = {};
      
      // Initialize all users
      users.forEach(user => {
        athleteMetrics[user.id] = {
          user_id: user.id,
          name: user.name || `${user.first_name || ''} ${user.last_name || ''}`.trim() || `User ${user.id}`,
          gender: user.gender ? user.gender.toLowerCase() : 'unknown',
          active: user.active,
          // Track best performance for each exercise individually
          exercises: {
            'Back Squat': { strength: null, power: null },
            'Front Squat': { strength: null, power: null },
            'Trap Bar Deadlift': { strength: null, power: null },
            'Bar RDL': { strength: null, power: null },
            'Trap Bar Jump': { strength: null, power: null },
            'Bench Press': { strength: null, power: null },
            'Vertical Jump': { jumpHeight: null }
          }
        };
      });
      
      // Process all sets
      sets.forEach(set => {
        if (!athleteMetrics[set.user_id]) return;
        
        const athlete = athleteMetrics[set.user_id];
        const exerciseConfig = EXERCISE_CONFIG[set.exercise_name];
        if (!exerciseConfig) return;
        
        // Handle Vertical Jump separately (uses set-level max_jump_height)
        if (exerciseConfig.movement_pattern === 'VERTICAL_JUMP') {
          if (!athlete.exercises[set.exercise_name]) {
            athlete.exercises[set.exercise_name] = { jumpHeight: null };
          }
          
          const exercise = athlete.exercises[set.exercise_name];
          if (set.max_jump_height && (!exercise.jumpHeight || set.max_jump_height > exercise.jumpHeight)) {
            exercise.jumpHeight = set.max_jump_height;
          }
          return;
        }
        
        // Get only valid reps (excluding ghost reps)
        const validReps = getValidReps(set);
        if (validReps.length === 0) return;
        
        // Initialize exercise object if it doesn't exist
        if (!athlete.exercises[set.exercise_name]) {
          athlete.exercises[set.exercise_name] = { strength: null, power: null };
        }
        
        // Process each valid rep in the set
        validReps.forEach(rep => {
          if (!set.weight || set.weight <= 0) return;
          
          const exercise = athlete.exercises[set.exercise_name];
          
          // Track best weight (strength) for this exercise
          if (!exercise.strength || set.weight > exercise.strength) {
            exercise.strength = set.weight;
          }
          
          // Track best power for this exercise
          let power = null;
          if (exerciseConfig.movement_pattern === 'JUMP') {
            // Use peak power for jumps
            if (rep.concentric_peak_power_per_mass_z) {
              power = convertPeakPowerToWatts(rep.concentric_peak_power_per_mass_z, set.weight);
            }
          } else {
            // Use mean power for other exercises
            if (rep.concentric_mean_velocity_z) {
              power = convertMeanPowerToWatts(rep.concentric_mean_velocity_z * set.weight);
            }
          }
          
          // Only count power if it's greater than 0
          if (power && power > 0 && (!exercise.power || power > exercise.power)) {
            exercise.power = power;
          }
        });
      });
      
      return Object.values(athleteMetrics);
    }

    // Calculate ratings for all athletes
    function calculateRatings(athleteMetrics) {
      const genders = ['male', 'female'];
      const exercises = ['Back Squat', 'Front Squat', 'Trap Bar Deadlift', 'Bar RDL', 'Trap Bar Jump', 'Bench Press'];
      const metrics = ['strength', 'power'];
      
      // Store rating scales for each gender/exercise/metric combination
      const ratingScales = {};
      
      // Calculate min/max/step for each exercise/metric within each gender
      genders.forEach(gender => {
        ratingScales[gender] = {};
        const genderAthletes = athleteMetrics.filter(a => a.gender === gender);
        
        exercises.forEach(exercise => {
          ratingScales[gender][exercise] = {};
          
          metrics.forEach(metric => {
            // Get all valid values for this exercise/metric
            const values = genderAthletes
              .map(a => a.exercises[exercise]?.[metric])
              .filter(v => v !== null && v !== undefined);
            
            if (values.length === 0) {
              ratingScales[gender][exercise][metric] = null;
              return;
            }
            
            const minValue = Math.min(...values);
            const maxValue = Math.max(...values);
            const range = maxValue - minValue;
            const step = range > 0 ? range / 50 : 1; // 49-99 = 50 points
            
            ratingScales[gender][exercise][metric] = { minValue, maxValue, step };
          });
        });
        
        // Add Vertical Jump rating scale
        ratingScales[gender]['Vertical Jump'] = {};
        const jumpHeights = genderAthletes
          .map(a => a.exercises['Vertical Jump']?.jumpHeight)
          .filter(v => v !== null && v !== undefined);
        
        if (jumpHeights.length > 0) {
          const minValue = Math.min(...jumpHeights);
          const maxValue = Math.max(...jumpHeights);
          const range = maxValue - minValue;
          const step = range > 0 ? range / 50 : 1;
          console.log(`${gender.toUpperCase()} Vertical Jump - Min: ${minValue.toFixed(2)} in, Max: ${maxValue.toFixed(2)} in, Range: ${range.toFixed(2)} in`);
          ratingScales[gender]['Vertical Jump']['jumpHeight'] = { minValue, maxValue, step };
        } else {
          ratingScales[gender]['Vertical Jump']['jumpHeight'] = null;
        }
      });
      
      // Calculate individual ratings for each athlete
      const ratedAthletes = athleteMetrics.map(athlete => {
        const result = { ...athlete };
        const gender = athlete.gender;
        
        // Store individual exercise ratings
        result.exerciseRatings = {};
        
        exercises.forEach(exercise => {
          result.exerciseRatings[exercise] = {};
          
          metrics.forEach(metric => {
            const value = athlete.exercises[exercise]?.[metric];
            const scale = ratingScales[gender]?.[exercise]?.[metric];
            
            if (value !== null && value !== undefined && scale) {
              const { minValue, step } = scale;
              const rawRating = 49 + ((value - minValue) / step);
              result.exerciseRatings[exercise][metric] = Math.max(49, Math.min(99, Math.round(rawRating)));
            } else {
              result.exerciseRatings[exercise][metric] = null;
            }
          });
        });
        
        // Add Vertical Jump rating
        result.exerciseRatings['Vertical Jump'] = {};
        const jumpHeight = athlete.exercises['Vertical Jump']?.jumpHeight;
        const jumpScale = ratingScales[gender]?.['Vertical Jump']?.['jumpHeight'];
        
        if (jumpHeight !== null && jumpHeight !== undefined && jumpScale) {
          const { minValue, step } = jumpScale;
          const rawRating = 49 + ((jumpHeight - minValue) / step);
          result.exerciseRatings['Vertical Jump']['jumpHeight'] = Math.max(49, Math.min(99, Math.round(rawRating)));
        } else {
          result.exerciseRatings['Vertical Jump']['jumpHeight'] = null;
        }
        
        // Calculate category ratings by averaging exercise ratings
        const lowerBodyExercises = ['Back Squat', 'Front Squat', 'Trap Bar Deadlift', 'Bar RDL', 'Trap Bar Jump'];
        const upperBodyExercises = ['Bench Press'];
        
        // Lower Body Strength = average of Back Squat, Front Squat, Trap Bar Deadlift, Bar RDL strength ratings
        const lowerStrengthRatings = ['Back Squat', 'Front Squat', 'Trap Bar Deadlift', 'Bar RDL']
          .map(ex => result.exerciseRatings[ex]?.strength)
          .filter(r => r !== null && r !== undefined);
        result.lower_body_strength_rating = lowerStrengthRatings.length > 0
          ? Math.round(lowerStrengthRatings.reduce((sum, r) => sum + r, 0) / lowerStrengthRatings.length)
          : 49;
        
        // Lower Body Power = average of all lower body exercises' power ratings
        const lowerPowerRatings = lowerBodyExercises
          .map(ex => result.exerciseRatings[ex]?.power)
          .filter(r => r !== null && r !== undefined);
        result.lower_body_power_rating = lowerPowerRatings.length > 0
          ? Math.round(lowerPowerRatings.reduce((sum, r) => sum + r, 0) / lowerPowerRatings.length)
          : 49;
        
        // Upper Body Strength = Bench Press strength rating
        result.upper_body_strength_rating = result.exerciseRatings['Bench Press']?.strength || 49;
        
        // Upper Body Power = Bench Press power rating
        result.upper_body_power_rating = result.exerciseRatings['Bench Press']?.power || 49;
        
        // Jump rating
        result.jump_rating = result.exerciseRatings['Vertical Jump']?.jumpHeight || 49;
        
        // Calculate overall rating (average of all 5 category ratings)
        const categoryRatings = [
          result.lower_body_strength_rating,
          result.lower_body_power_rating,
          result.upper_body_strength_rating,
          result.upper_body_power_rating,
          result.jump_rating
        ].filter(r => r !== null && r !== undefined && r !== 49);
        
        result.overall_rating = categoryRatings.length > 0 
          ? Math.round(categoryRatings.reduce((sum, r) => sum + r, 0) / categoryRatings.length)
          : 49;
        
        return result;
      });
      
      return ratedAthletes;
    }

    // UI Functions
    function switchGender(gender) {
      currentGender = gender;
      
      // Update active tab
      document.querySelectorAll('.gender-tab').forEach(tab => {
        tab.classList.remove('active');
      });
      document.querySelector(`[data-gender="${gender}"]`).classList.add('active');
      
      // Update athlete dropdown
      updateAthleteDropdown();
      
      // Clear current selection
      selectedAthlete = null;
      document.getElementById('ratingDisplay').style.display = 'none';
    }

    function updateAthleteDropdown() {
      const dropdown = document.getElementById('athleteSelector');
      dropdown.innerHTML = '<option value="">Select an athlete...</option>';
      
      // Check if user is authenticated
      const session = getAthleteSession();
      if (!session) {
        console.log('No session found, redirecting to login');
        window.location.href = 'index.html';
        return;
      }
      
      // Filter athletes based on admin status
      let activeAthletes = allRatings.filter(athlete => 
        athlete.active === true && athlete.gender === currentGender
      );
      
      // If not admin, only show the logged-in athlete
      if (!session.isAdmin) {
        activeAthletes = activeAthletes.filter(athlete => athlete.user_id === session.id);
      }
      
      activeAthletes.sort((a, b) => a.name.localeCompare(b.name));
      
      activeAthletes.forEach(athlete => {
        const option = document.createElement('option');
        option.value = athlete.user_id;
        option.textContent = athlete.name;
        dropdown.appendChild(option);
      });
      
      // Auto-select if only one athlete (non-admin user)
      if (activeAthletes.length === 1) {
        dropdown.value = activeAthletes[0].user_id;
        selectAthlete();
      }
      
      console.log(`Updated dropdown with ${activeAthletes.length} active ${currentGender} athletes`);
    }

    function selectAthlete() {
      const dropdown = document.getElementById('athleteSelector');
      const userId = parseInt(dropdown.value);
      
      if (!userId) {
        document.getElementById('ratingDisplay').style.display = 'none';
        return;
      }
      
      selectedAthlete = allRatings.find(athlete => athlete.user_id === userId);
      if (selectedAthlete) {
        displayAthleteRatings(selectedAthlete);
      }
    }

    function displayAthleteRatings(athlete) {
      // Show the rating display
      document.getElementById('ratingDisplay').style.display = 'block';
      
      // Update overall rating
      document.getElementById('overallScore').textContent = athlete.overall_rating;
      
      // Build details showing which exercises contributed to each rating
      const lowerStrengthExercises = ['Back Squat', 'Front Squat', 'Trap Bar Deadlift', 'Bar RDL'];
      const lowerPowerExercises = ['Back Squat', 'Front Squat', 'Trap Bar Deadlift', 'Bar RDL', 'Trap Bar Jump'];
      const upperStrengthExercises = ['Bench Press'];
      const upperPowerExercises = ['Bench Press'];
      
      // Helper function to build details string
      const buildDetails = (exercises, metric) => {
        const ratings = exercises
          .map(ex => {
            const rating = athlete.exerciseRatings[ex]?.[metric];
            return rating ? `${ex}: ${rating}` : null;
          })
          .filter(r => r !== null);
        
        if (ratings.length === 0) return 'No reps attempted';
        return ratings.join(', ');
      };
      
      // Update individual ratings with exercise details
      updateRatingCard('lowerStrength', 
        athlete.lower_body_strength_rating !== 49 ? athlete.lower_body_strength_rating : 'N/A', 
        buildDetails(lowerStrengthExercises, 'strength'));
      
      updateRatingCard('lowerPower', 
        athlete.lower_body_power_rating !== 49 ? athlete.lower_body_power_rating : 'N/A', 
        buildDetails(lowerPowerExercises, 'power'));
      
      updateRatingCard('upperStrength', 
        athlete.upper_body_strength_rating !== 49 ? athlete.upper_body_strength_rating : 'N/A', 
        buildDetails(upperStrengthExercises, 'strength'));
      
      updateRatingCard('upperPower', 
        athlete.upper_body_power_rating !== 49 ? athlete.upper_body_power_rating : 'N/A', 
        buildDetails(upperPowerExercises, 'power'));
      
      // Update jump rating
      const jumpHeight = athlete.exercises['Vertical Jump']?.jumpHeight;
      const jumpDetail = jumpHeight ? `Max height: ${jumpHeight.toFixed(1)} in` : 'No jumps attempted';
      updateRatingCard('jump', 
        athlete.jump_rating !== 49 ? athlete.jump_rating : 'N/A', 
        jumpDetail);
    }

    function updateRatingCard(prefix, rating, details) {
      document.getElementById(`${prefix}Score`).textContent = rating;
      
      // If N/A, show "No Reps Attempted", otherwise show the details
      if (rating === 'N/A' || rating === 49) {
        document.getElementById(`${prefix}Details`).textContent = 'No Reps Attempted';
      } else {
        document.getElementById(`${prefix}Details`).textContent = details;
      }
      
      // Update progress bar (handle both numeric ratings and 'N/A')
      if (rating === 'N/A' || rating === 49) {
        document.getElementById(`${prefix}Bar`).style.width = '0%';
      } else {
        const percentage = ((rating - 49) / 50) * 100; // Convert 49-99 to 0-100%
        document.getElementById(`${prefix}Bar`).style.width = `${percentage}%`;
      }
    }

    function showError(message) {
      document.getElementById('loadingState').style.display = 'none';
      document.getElementById('errorState').textContent = message;
      document.getElementById('errorState').style.display = 'block';
    }

    function updateProgress(percent, message) {
      document.getElementById('progressBarFill').style.width = `${percent}%`;
      document.getElementById('loadingPercentage').textContent = `${Math.round(percent)}%`;
      document.getElementById('loadingMessage').textContent = message;
    }

    function hideLoading() {
      document.getElementById('loadingContainer').classList.add('hidden');
    }

    let progressInterval = null;

    function updateProgress(percent, message) {
      document.getElementById('progressBarFill').style.width = `${percent}%`;
      document.getElementById('loadingPercentage').textContent = `${Math.round(percent)}%`;
      document.getElementById('loadingMessage').textContent = message;
    }

    function startContinuousProgress(duration, message) {
      return new Promise(resolve => {
        let startTime = Date.now();
        let currentPercent = 0;
        
        updateProgress(0, message);
        
        progressInterval = setInterval(() => {
          const elapsed = Date.now() - startTime;
          currentPercent = Math.min(99, (elapsed / duration) * 100);
          updateProgress(currentPercent, message);
          
          if (currentPercent >= 99) {
            clearInterval(progressInterval);
            resolve();
          }
        }, 50);
      });
    }

    function stopProgressAndComplete(message) {
      if (progressInterval) {
        clearInterval(progressInterval);
        progressInterval = null;
      }
      updateProgress(100, message);
    }

    function hideLoading() {
      document.getElementById('loadingContainer').classList.add('hidden');
    }

    // Initialize the page
    async function initializePage() {
      try {
        // Check authentication first
        if (!requireAthleteAuth()) {
          return; // Will redirect to login
        }
        
        console.log('Initializing Hornet Ratings page...');
        
        // Start continuous 30-second progress animation
        const progressPromise = startContinuousProgress(30000, 'Calculating ratings...');
        
        // Load all data
        console.log('Loading users...');
        allUsers = await loadAllUsers();
        
        console.log('Loading exercises...');
        allExercises = await loadExercises();
        
        console.log('Loading sets data...');
        allSets = await loadSetsData(allExercises);
        
        console.log('Calculating athlete metrics...');
        const athleteMetrics = calculateAthleteMetrics(allUsers, allSets);
        
        console.log('Calculating ratings...');
        allRatings = calculateRatings(athleteMetrics);
        
        console.log(`Calculated ratings for ${allRatings.length} athletes`);
        
        // Data is ready - jump to 100%
        stopProgressAndComplete('Ratings ready!');
        
        // Hide loading state
        document.getElementById('loadingState').style.display = 'none';
        
        // Update UI
        updateAthleteDropdown();
        
        await new Promise(resolve => setTimeout(resolve, 500));
        hideLoading();
        
      } catch (error) {
        console.error('Error initializing page:', error);
        stopProgressAndComplete('Error loading data. Please refresh.');
        showError('Failed to load rating data. Please try again.');
      }
    }

    // Start initialization when page loads
    document.addEventListener('DOMContentLoaded', initializePage);
  </script>
</body>
</html>
