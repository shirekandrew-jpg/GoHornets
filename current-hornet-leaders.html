<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Current Hornet Leaders</title>
  <link rel="icon" type="image/svg+xml" href="favicon.svg">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
  <script src="auth.js"></script>
  <style>
    /* Gender tabs styling */
    .gender-tabs {
      display: flex;
      justify-content: center;
      margin-bottom: 2rem;
      gap: 1rem;
    }

    .gender-tab {
      padding: 0.75rem 2rem;
      border-radius: 12px;
      border: 2px solid var(--hornet-green);
      background: transparent;
      color: var(--hornet-green);
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .gender-tab.active {
      background: var(--hornet-green);
      color: var(--hornet-gold);
    }

    .gender-tab:hover {
      background: var(--hornet-green-light);
      color: var(--hornet-gold);
    }

    /* Exercise section styling */
    .exercise-section {
      margin-bottom: 3rem;
      padding-bottom: 2rem;
      border-bottom: 2px solid var(--border-light);
    }

    .exercise-section h2 {
      text-align: center;
      font-size: 2rem;
      font-weight: 700;
      color: var(--hornet-green);
      margin-bottom: 2rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    /* All-time leaderboards container */
    .alltime-leaderboards-container {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 2rem;
      max-width: 1200px;
      margin: 0 auto;
    }

    /* All-time leaderboard wrapper */
    .alltime-leaderboard-wrapper {
      background: var(--surface);
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      overflow: hidden;
      border: 1px solid var(--border-light);
    }

    /* All-time leaderboard header */
    .alltime-leaderboard-header {
      background: linear-gradient(135deg, var(--hornet-green) 0%, var(--hornet-green-light) 100%);
      padding: 1rem;
      text-align: center;
    }

    .alltime-leaderboard-header h3 {
      font-size: 1.2rem;
      font-weight: 700;
      color: var(--hornet-gold);
      margin: 0;
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }

    /* All-time table styling */
    .alltime-leaderboard-table {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0;
      table-layout: fixed;
    }

    .alltime-leaderboard-table th {
      background: var(--hornet-green);
      color: white;
      padding: 0.75rem 0.5rem;
      font-weight: 700;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      border-bottom: 2px solid var(--hornet-green-dark);
    }

    .alltime-leaderboard-table td {
      padding: 0.75rem 0.5rem;
      border-bottom: 1px solid var(--border-light);
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-primary);
      background: white;
    }

    /* Column widths */
    .alltime-leaderboard-table th:first-child,
    .alltime-leaderboard-table td:first-child {
      width: 15%;
      text-align: center;
    }

    .alltime-leaderboard-table th:nth-child(2),
    .alltime-leaderboard-table td:nth-child(2) {
      width: 60%;
      text-align: left;
    }

    .alltime-leaderboard-table th:nth-child(3),
    .alltime-leaderboard-table td:nth-child(3) {
      width: 25%;
      text-align: right;
    }

    /* Back button styling */
    .back-button {
      padding: 0.5rem 1rem;
      border-radius: 8px;
      border: 2px solid var(--hornet-green);
      background: transparent;
      color: var(--hornet-green);
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .back-button:hover {
      background: var(--hornet-green);
      color: var(--hornet-gold);
    }

    /* Loading state */
    .loading {
      text-align: center;
      padding: 2rem;
      color: var(--text-secondary);
      font-style: italic;
    }

    /* Leaderboard columns layout */
    .leaderboard-columns {
      display: flex;
      gap: 2rem;
      margin-top: 1rem;
    }

    .leaderboard-column {
      flex: 1;
    }

    .column-header {
      margin-bottom: 1rem;
    }

    .column-header h3 {
      margin: 0;
      color: var(--hornet-green);
      font-size: 1.1rem;
      font-weight: 700;
    }

    /* Responsive design */
    @media (max-width: 768px) {
      .alltime-leaderboards-container {
        grid-template-columns: 1fr;
        gap: 1rem;
      }

      .gender-tabs {
        flex-direction: column;
        align-items: center;
      }

      .exercise-section h2 {
        font-size: 1.5rem;
      }
    }
  </style>
</head>

<body>
  <main class="main-content">
    <!-- Top Controls -->
    <div class="top-controls">
      <button class="back-button" onclick="navigateWithHornets('index.html')">
        ‚Üê Back to Home
      </button>
    </div>

    <!-- Gender Selection Tabs -->
    <div class="gender-tabs">
      <button class="gender-tab active" data-gender="male" onclick="switchGender('male')">
        Male Leaders
      </button>
      <button class="gender-tab" data-gender="female" onclick="switchGender('female')">
        Female Leaders
      </button>
    </div>

    <!-- Back Squat Section -->
    <div class="exercise-section">
      <h2>Back Squat</h2>
      
      <div class="alltime-leaderboards-container">
        <!-- Mean Power Leaderboard -->
        <div class="alltime-leaderboard-wrapper">
          <div class="alltime-leaderboard-header">
            <h3>Mean Power Leaders</h3>
          </div>
          <table class="alltime-leaderboard-table" id="meanPowerTable">
            <thead>
              <tr>
                <th>Rank</th>
                <th>Athlete</th>
                <th>Mean Power</th>
              </tr>
            </thead>
            <tbody id="meanPowerTableBody">
              <tr><td colspan="3" class="loading">Loading...</td></tr>
            </tbody>
          </table>
        </div>

        <!-- Weight Leaderboard -->
        <div class="alltime-leaderboard-wrapper">
          <div class="alltime-leaderboard-header">
            <h3>Weight Leaders</h3>
          </div>
          <table class="alltime-leaderboard-table" id="weightTable">
            <thead>
              <tr>
                <th>Rank</th>
                <th>Athlete</th>
                <th>Weight</th>
              </tr>
            </thead>
            <tbody id="weightTableBody">
              <tr><td colspan="3" class="loading">Loading...</td></tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <!-- Bench Press Section -->
    <div class="exercise-section">
      <h2>Bench Press</h2>
      
      <div class="alltime-leaderboards-container">
        <!-- Mean Power Leaderboard -->
        <div class="alltime-leaderboard-wrapper">
          <div class="alltime-leaderboard-header">
            <h3>Mean Power Leaders</h3>
          </div>
          <table class="alltime-leaderboard-table" id="benchMeanPowerTable">
            <thead>
              <tr>
                <th>Rank</th>
                <th>Athlete</th>
                <th>Peak Power</th>
              </tr>
            </thead>
            <tbody id="benchMeanPowerTableBody">
              <tr><td colspan="3" class="loading">Loading...</td></tr>
            </tbody>
          </table>
        </div>

        <!-- Weight Leaderboard -->
        <div class="alltime-leaderboard-wrapper">
          <div class="alltime-leaderboard-header">
            <h3>Weight Leaders</h3>
          </div>
          <table class="alltime-leaderboard-table" id="benchWeightTable">
            <thead>
              <tr>
                <th>Rank</th>
                <th>Athlete</th>
                <th>Weight</th>
              </tr>
            </thead>
            <tbody id="benchWeightTableBody">
              <tr><td colspan="3" class="loading">Loading...</td></tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <!-- Trap Bar Deadlift Section -->
    <div class="exercise-section">
      <h2>Trap Bar Deadlift</h2>
      
      <div class="alltime-leaderboards-container">
        <!-- Mean Power Leaderboard -->
        <div class="alltime-leaderboard-wrapper">
          <div class="alltime-leaderboard-header">
            <h3>Mean Power Leaders</h3>
          </div>
          <table class="alltime-leaderboard-table" id="trapMeanPowerTable">
            <thead>
              <tr>
                <th>Rank</th>
                <th>Athlete</th>
                <th>Mean Power</th>
              </tr>
            </thead>
            <tbody id="trapBarMeanPowerTableBody">
              <tr><td colspan="3" class="loading">Loading...</td></tr>
            </tbody>
          </table>
        </div>

        <!-- Weight Leaderboard -->
        <div class="alltime-leaderboard-wrapper">
          <div class="alltime-leaderboard-header">
            <h3>Weight Leaders</h3>
          </div>
          <table class="alltime-leaderboard-table" id="trapBarWeightTable">
            <thead>
              <tr>
                <th>Rank</th>
                <th>Athlete</th>
                <th>Weight</th>
              </tr>
            </thead>
            <tbody id="trapBarWeightTableBody">
              <tr><td colspan="3" class="loading">Loading...</td></tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <!-- Front Squat Section -->
    <div class="exercise-section">
      <h2>Front Squat</h2>
      
      <div class="alltime-leaderboards-container">
        <!-- Mean Power Leaderboard -->
        <div class="alltime-leaderboard-wrapper">
          <div class="alltime-leaderboard-header">
            <h3>Mean Power Leaders</h3>
          </div>
          <table class="alltime-leaderboard-table" id="frontSquatMeanPowerTable">
            <thead>
              <tr>
                <th>Rank</th>
                <th>Athlete</th>
                <th>Mean Power</th>
              </tr>
            </thead>
            <tbody id="frontSquatMeanPowerTableBody">
              <tr><td colspan="3" class="loading">Loading...</td></tr>
            </tbody>
          </table>
        </div>

        <!-- Weight Leaderboard -->
        <div class="alltime-leaderboard-wrapper">
          <div class="alltime-leaderboard-header">
            <h3>Weight Leaders</h3>
          </div>
          <table class="alltime-leaderboard-table" id="frontSquatWeightTable">
            <thead>
              <tr>
                <th>Rank</th>
                <th>Athlete</th>
                <th>Weight</th>
              </tr>
            </thead>
            <tbody id="frontSquatWeightTableBody">
              <tr><td colspan="3" class="loading">Loading...</td></tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>

    <!-- Vertical Jump Section -->
    <div class="exercise-section">
      <h2>Vertical Jump</h2>
      
      <div class="alltime-leaderboards-container" style="grid-template-columns: 1fr; max-width: 600px; margin: 0 auto;">
        <!-- Max Jump Height Leaderboard -->
        <div class="alltime-leaderboard-wrapper">
          <div class="alltime-leaderboard-header">
            <h3>Max Jump Height Leaders</h3>
          </div>
          <table class="alltime-leaderboard-table" id="verticalJumpMaxHeightTable">
            <thead>
              <tr>
                <th>Rank</th>
                <th>Athlete</th>
                <th>Jump Height</th>
              </tr>
            </thead>
            <tbody id="verticalJumpMaxHeightTableBody">
              <tr><td colspan="3" class="loading">Loading...</td></tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </main>

  <!-- Hornet Animation Container -->
  <div id="hornetContainer" class="hornet-container"></div>

  <script>
    // Hornet animation functions (copied from index.html)
    function navigateWithHornets(url) {
      if (url === '#') return;
      
      createHornetSwarm();
      
      setTimeout(() => {
        window.location.href = url;
      }, 1200);
    }

    function createHornetSwarm() {
      const container = document.getElementById('hornetContainer');
      container.innerHTML = '';
      
      for (let i = 0; i < 20; i++) {
        const hornet = document.createElement('div');
        hornet.className = 'hornet';
        
        hornet.innerHTML = `
          <div style="
            position: relative;
            width: 24px;
            height: 12px;
            background: linear-gradient(90deg, #1a1a1a 0%, #8b4513 20%, #ffd700 40%, #1a1a1a 60%, #8b4513 80%, #ffd700 100%);
            border-radius: 60% 40%;
            box-shadow: 
              0 0 4px rgba(255, 215, 0, 0.8),
              inset 0 1px 0 rgba(255, 255, 255, 0.4),
              inset 0 -1px 0 rgba(0, 0, 0, 0.3);
          ">
            <div style="
              position: absolute;
              top: -2px;
              left: 8px;
              width: 12px;
              height: 8px;
              background: radial-gradient(ellipse, rgba(255, 255, 255, 0.6) 0%, rgba(200, 220, 255, 0.3) 70%, transparent 100%);
              border-radius: 80% 20%;
              animation: wingFlap 0.08s infinite alternate;
              transform-origin: 20% 50%;
            "></div>
            <div style="
              position: absolute;
              top: -2px;
              left: 4px;
              width: 12px;
              height: 8px;
              background: radial-gradient(ellipse, rgba(255, 255, 255, 0.6) 0%, rgba(200, 220, 255, 0.3) 70%, transparent 100%);
              border-radius: 80% 20%;
              animation: wingFlap 0.08s infinite alternate-reverse;
              transform-origin: 80% 50%;
            "></div>
            <div style="
              position: absolute;
              top: 2px;
              left: 2px;
              width: 4px;
              height: 4px;
              background: #1a1a1a;
              border-radius: 50%;
              box-shadow: 8px 0 0 #1a1a1a;
            "></div>
          </div>
        `;
        
        const startY = Math.random() * window.innerHeight;
        const startX = -150;
        const duration = 3 + Math.random() * 3;
        const delay = Math.random() * 2;
        const size = 0.8 + Math.random() * 0.6;
        
        hornet.style.cssText = `
          position: fixed;
          left: ${startX}px;
          top: ${startY}px;
          z-index: 9999;
          pointer-events: none;
          animation: flyAcross ${duration}s cubic-bezier(0.25, 0.46, 0.45, 0.94) ${delay}s forwards;
          transform-origin: center;
          transform: scale(${size});
          filter: drop-shadow(2px 2px 6px rgba(0, 0, 0, 0.4));
        `;
        
        container.appendChild(hornet);
        
        setTimeout(() => {
          if (hornet.parentNode) {
            hornet.parentNode.removeChild(hornet);
          }
        }, (duration + delay + 1) * 1000);
      }
    }

    // API and data handling
    const AUTH_HEADER = 'Bearer 31606b711ce9ef5a7b7d887dcbe60c6601f6691d7d3b9bab3f0eeb0ab9db';
    const ORG_ID = 7617;
    
    let allOrganizationUsers = [];
    let refsUsers = []; // Users from the sets API refs
    let currentGender = 'male';
    let exerciseIds = {
      backSquat: null,
      benchPress: null,
      trapBarDeadlift: null,
      frontSquat: null,
      verticalJump: null
    };

    // Unit conversion constants
    const M_PER_IN = 0.0254;
    const KG_PER_LBS = 0.453592;
    const N_PER_LBS = 4.44822;

    // Convert power from (in^2 * lbs) / sec^3 to watts
    function convertPowerToWatts(powerPerMassZ, weight_lbs) {
      if (powerPerMassZ == null || weight_lbs == null) return null;
      return (M_PER_IN * M_PER_IN) * KG_PER_LBS * powerPerMassZ * weight_lbs;
    }

    // Convert mean power from (in * lbs / s) to watts
    function convertMeanPowerToWatts(meanPowerInLbsInS) {
      if (meanPowerInLbsInS == null) return null;
      return M_PER_IN * N_PER_LBS * meanPowerInLbsInS;
    }

    // Filter out ghost reps from a set's reps array
    function getValidReps(set) {
      if (!set.reps || set.reps.length === 0) return [];
      
      // If there are ghost rep indices, filter them out
      if (set.error && set.error.ghost_rep_indices && set.error.ghost_rep_indices.length > 0) {
        const ghostIndices = new Set(set.error.ghost_rep_indices);
        return set.reps.filter((rep, index) => !ghostIndices.has(index));
      }
      
      // No ghost reps, return all reps
      return set.reps;
    }

    // Load tracked exercises and find Back Squat ID
    async function loadExercises() {
      try {
        const response = await fetch('https://api.perch.fit/v3/exercises', {
          headers: { 'Authorization': AUTH_HEADER, 'accept': 'application/json' }
        });
        if (response.ok) {
          const data = await response.json();
          const exercises = data.data || [];
          
          console.log('Available exercises:', exercises.map(ex => ex.name));
          
          // Helper function to find exercise with actual data
          async function findExerciseWithData(exerciseMatches, exerciseName) {
            for (const exercise of exerciseMatches) {
              try {
                // Test if this exercise has any recent tracked sets
                const testResponse = await fetch('https://api.perch.fit/v3/sets', {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Authorization': AUTH_HEADER,
                    'accept': 'application/json'
                  },
                  body: JSON.stringify({
                    limit: 10,
                    group_id: ORG_ID,
                    exercise_id: exercise.id,
                    untracked: 'EXCLUDE',
                    include_reps: false
                  })
                });
                
                if (testResponse.ok) {
                  const testData = await testResponse.json();
                  if (testData.data && testData.data.length > 0) {
                    console.log(`Found ${exerciseName} exercise ID: ${exercise.id} (${exercise.name}) with ${testData.data.length} sets`);
                    return exercise.id;
                  }
                }
              } catch (err) {
                console.log(`Error testing ${exerciseName} exercise ID ${exercise.id}:`, err);
              }
            }
            
            // If no exercise has data, return the first one as fallback
            if (exerciseMatches.length > 0) {
              console.log(`No ${exerciseName} exercise with data found, using first match: ${exerciseMatches[0].id} (${exerciseMatches[0].name})`);
              return exerciseMatches[0].id;
            }
            
            console.log(`${exerciseName} exercise not found`);
            return null;
          }

          // Find all matching exercises for each type
          const backSquatExercises = exercises.filter(ex => 
            ex.name && (ex.name.toLowerCase().includes('back squat') ||
            ex.name.toLowerCase().includes('backsquat'))
          );
          
          const benchPressExercises = exercises.filter(ex => 
            ex.name && (ex.name.toLowerCase().includes('bench press') ||
            ex.name.toLowerCase().includes('benchpress'))
          );
          
          const trapBarDeadliftExercises = exercises.filter(ex => 
            ex.name && (ex.name.toLowerCase().includes('trap bar deadlift') ||
            ex.name.toLowerCase().includes('trapbar deadlift') ||
            ex.name.toLowerCase().includes('trap bar dl'))
          );

          const frontSquatExercises = exercises.filter(ex => 
            ex.name && (ex.name.toLowerCase().includes('front squat') ||
            ex.name.toLowerCase().includes('frontsquat'))
          );
          
          // Find exercises with actual data
          if (backSquatExercises.length > 0) {
            exerciseIds.backSquat = await findExerciseWithData(backSquatExercises, 'Back Squat');
          } else {
            console.error('Back Squat exercise not found');
          }
          
          if (benchPressExercises.length > 0) {
            console.log('Found Bench Press exercises:', benchPressExercises.map(ex => `${ex.id}: ${ex.name}`));
            exerciseIds.benchPress = await findExerciseWithData(benchPressExercises, 'Bench Press');
            console.log('Bench Press exercise ID resolved:', exerciseIds.benchPress);
          } else {
            console.error('Bench Press exercise not found in available exercises:', exercises.map(ex => ex.name));
          }
          
          if (trapBarDeadliftExercises.length > 0) {
            exerciseIds.trapBarDeadlift = await findExerciseWithData(trapBarDeadliftExercises, 'Trap Bar Deadlift');
          } else {
            console.error('Trap Bar Deadlift exercise not found');
          }

          if (frontSquatExercises.length > 0) {
            exerciseIds.frontSquat = await findExerciseWithData(frontSquatExercises, 'Front Squat');
          } else {
            console.error('Front Squat exercise not found');
          }

          // Try to find Vertical Jump by ID first (449), then by name
          console.log('Looking for Vertical Jump exercise...');
          const verticalJumpById = exercises.find(ex => ex.id === 449);
          if (verticalJumpById) {
            exerciseIds.verticalJump = 449;
            console.log('Found Vertical Jump exercise by ID: 449 (', verticalJumpById.name, ')');
          } else {
            console.log('Vertical Jump ID 449 not found, searching by name...');
            const verticalJumpExercises = exercises.filter(ex => 
              ex.name && (ex.name.toLowerCase().includes('vertical jump') ||
              ex.name.toLowerCase().includes('vert jump') ||
              ex.name.toLowerCase().includes('jump vertical'))
            );
            
            console.log('Vertical Jump exercises found by name:', verticalJumpExercises.map(ex => `${ex.id}: ${ex.name}`));
            
            if (verticalJumpExercises.length > 0) {
              exerciseIds.verticalJump = await findExerciseWithData(verticalJumpExercises, 'Vertical Jump');
              console.log('Vertical Jump exercise ID resolved:', exerciseIds.verticalJump);
            } else {
              console.error('Vertical Jump exercise not found in available exercises:', exercises.map(ex => ex.name));
            }
          }
        }
      } catch (error) {
        console.error('Error loading exercises:', error);
      }
    }

    // Fetch all active users in the organization (MODIFIED FOR CURRENT LEADERS)
    async function loadAllOrganizationUsers() {
      try {
        let hasMore = true;
        let nextToken = null;
        const limit = 500;
        
        while (hasMore) {
          const body = {
            limit: limit,
            next_token: nextToken,
            group_id: ORG_ID
          };

          const response = await fetch('https://api.perch.fit/v2/users', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': AUTH_HEADER,
              'accept': 'application/json'
            },
            body: JSON.stringify(body)
          });

          if (!response.ok) {
            console.warn(`Users fetch failed ${response.status} (likely CORS). Falling back to refs.users only.`);
            return;
          }
          
          const data = await response.json();
          const users = data.data || [];
          // Filter to only include active users for Current Leaders
          const activeUsers = users.filter(user => user.active === true);
          allOrganizationUsers = allOrganizationUsers.concat(activeUsers);
          
          if (data.truncated && data.next_token) {
            nextToken = data.next_token;
          } else {
            hasMore = false;
          }
        }
        
        console.log('Loaded active organization users:', allOrganizationUsers.length);
      } catch (error) {
        console.error('Error loading users:', error);
      }
    }

    // Get user name and gender by id
    function getUserInfo(userId) {
      // First check organization users
      let user = allOrganizationUsers.find(u => u.id === userId);
      
      // If not found, check refs users
      if (!user) {
        user = refsUsers.find(u => u.id === userId);
      }
      
      if (!user) {
        console.warn(`User ${userId} not found in either org users or refs`);
        return { name: `User ${userId}`, gender: 'unknown' };
      }
      
      // Handle different name field structures
      let name = user.display_name || user.name;
      if (!name) {
        name = `${user.first_name || ''} ${user.last_name || ''}`.trim();
      }
      if (!name) {
        name = `User ${userId}`;
      }
      
      const gender = user.gender ? user.gender.toLowerCase() : 'unknown';
      
      return { name, gender };
    }

    // Fetch sets data for any exercise with pagination
    async function fetchExerciseData(exerciseId, exerciseName) {
      if (!exerciseId) {
        console.error(`${exerciseName} exercise ID not found`);
        return [];
      }

      try {
        let allSets = [];
        let offset = 0;
        const limit = 500;
        let hasMore = true;
        
        // Get data from the last 10 years (all-time) - expanded range
        const endTime = Math.floor(Date.now() / 1000);
        const beginTime = endTime - (10 * 365 * 24 * 60 * 60); // 10 years ago
        
        console.log(`Fetching data from ${new Date(beginTime * 1000).toLocaleDateString()} to ${new Date(endTime * 1000).toLocaleDateString()}`);

        let nextToken = null;
        
        while (hasMore) {
          const body = {
            limit: limit,
            next_token: nextToken,
            group_id: ORG_ID,
            exercise_id: exerciseId,
            include_reps: true,
            untracked: 'EXCLUDE'  // Only get tracked sets that have detailed rep data and power metrics
          };
          
          console.log('Fetching sets with body:', body);
          
          const response = await fetch('https://api.perch.fit/v3/sets', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': AUTH_HEADER,
              'accept': 'application/json'
            },
            body: JSON.stringify(body)
          });
          
          if (!response.ok) {
            const errorText = await response.text();
            console.error(`HTTP error! status: ${response.status}, response: ${errorText}`);
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const data = await response.json();
          console.log(`API Response for ${exerciseName}:`, data);
          
          // Store users from refs for name lookup, but also filter for active users
          if (data.refs && data.refs.users) {
            // Merge with existing refs users, avoiding duplicates, and only include active users
            const newUsers = data.refs.users.filter(newUser => 
              newUser.active === true && !refsUsers.some(existingUser => existingUser.id === newUser.id)
            );
            refsUsers = refsUsers.concat(newUsers);
            console.log(`Added ${newUsers.length} new active users from refs, total active refs users: ${refsUsers.length}`);
          }
          
          const sets = data.data || [];
          
          if (sets.length === 0 && nextToken === null) {
            // No data found on first request
            console.log('No sets found for this exercise and time range');
            hasMore = false;
          } else if (sets.length === 0) {
            // No more data on subsequent requests
            hasMore = false;
          } else {
            allSets = allSets.concat(sets);
            
            // Check pagination
            if (data.truncated && data.next_token) {
              nextToken = data.next_token;
            } else {
              hasMore = false;
            }
          }
        }
        
        console.log(`Total ${exerciseName} sets fetched:`, allSets.length);
        return allSets;
      } catch (error) {
        console.error(`Error fetching ${exerciseName} data:`, error);
        return [];
      }
    }

    // Process sets data to create leaderboards - now processes individual reps like active leaderboards (MODIFIED FOR CURRENT LEADERS)
    function processLeaderboardData(sets, exerciseName = '') {
      console.log(`Processing ${sets.length} sets for gender: ${currentGender}`);
      
      // Debug first few sets if no reps are found
      const setsWithRepsCheck = sets.filter(s => s.reps && s.reps.length > 0);
      const setsWithTrackedData = sets.filter(s => s.tracked === true);
      const setsWithPowerData = sets.filter(s => s.max_peak_power || s.avg_peak_power || s.min_peak_power);
      
      console.log(`${exerciseName} - Set analysis:`, {
        totalSets: sets.length,
        setsWithReps: setsWithRepsCheck.length,
        trackedSets: setsWithTrackedData.length,
        setsWithPowerData: setsWithPowerData.length,
        untrackedSets: sets.filter(s => s.tracked === false).length
      });
      
      if (setsWithTrackedData.length > 0) {
        console.log(`${exerciseName} - Sample tracked set:`, setsWithTrackedData[0]);
      }
      
      if (setsWithRepsCheck.length === 0 && sets.length > 0) {
        console.log(`${exerciseName} - No sets with reps found. Checking if we need tracked sets only...`);
      }
      
      const userStats = new Map();
      let validSets = 0;
      let setsWithReps = 0;
      let repsWithPowerData = 0;
      let setsWithWeightOnly = 0;
      let totalRepsProcessed = 0;

      sets.forEach(set => {
        validSets++;
        
        const userInfo = getUserInfo(set.user_id);
        
        // For Current Leaders, only include active users - check both user sources
        const user = allOrganizationUsers.find(u => u.id === set.user_id) || refsUsers.find(u => u.id === set.user_id);
        if (!user || user.active !== true) return;
        
        // Allow unknown gender to show up in current selection for debugging
        if (userInfo.gender !== currentGender && userInfo.gender !== 'unknown') return;

        const userId = set.user_id;
        
        if (!userStats.has(userId)) {
          userStats.set(userId, {
            name: userInfo.name,
            gender: userInfo.gender,
            maxMeanPower: 0,
            maxWeight: 0
          });
        }

        const userStat = userStats.get(userId);

        // Get only valid reps (excluding ghost reps)
        const validReps = getValidReps(set);
        
        // Process individual reps for mean power (like active leaderboards)
        if (validReps.length > 0) {
          setsWithReps++;
          
          validReps.forEach(rep => {
            totalRepsProcessed++;
            
            // Process individual rep mean power (calculated from mean velocity)
            if (rep.concentric_mean_velocity_z && set.weight) {
              repsWithPowerData++;
              // Calculate mean power: mean_velocity * weight, then convert to watts
              const repMeanPowerWatts = convertMeanPowerToWatts(rep.concentric_mean_velocity_z * set.weight);
              
              if (repMeanPowerWatts && repMeanPowerWatts > userStat.maxMeanPower) {
                userStat.maxMeanPower = repMeanPowerWatts;
              }
            }
          });
        } else {
          // For sets without reps, try to use set-level mean power if available
          // Try different mean power field names that might be available
          const setPowerValue = set.max_mean_power || set.avg_mean_power || set.min_mean_power;
          
          if (setPowerValue && set.weight) {
            // Convert set-level mean power - according to schema, mean power is in (in * lbs / s)
            // Convert to watts: m/in * N/lbs * mean_power
            const setMeanPowerWatts = convertMeanPowerToWatts(setPowerValue);
            
            if (setMeanPowerWatts && setMeanPowerWatts > userStat.maxMeanPower) {
              userStat.maxMeanPower = setMeanPowerWatts;
              repsWithPowerData++; // Count this as power data
              console.log(`${exerciseName} - Using set-level mean power: ${setPowerValue} -> ${setMeanPowerWatts}W for user ${userInfo.name}`);
            }
          }
        }

        // Track max weight (works for both tracked and untracked sets)
        if (set.weight && set.weight > userStat.maxWeight) {
          userStat.maxWeight = set.weight;
          setsWithWeightOnly++;
        }
      });

      const result = Array.from(userStats.values());
      console.log(`Processed stats: ${validSets} sets, ${setsWithReps} with reps, ${totalRepsProcessed} total reps, ${repsWithPowerData} with power data, ${setsWithWeightOnly} with weight data`);
      console.log(`Found ${result.length} active users with data:`, result.map(u => ({name: u.name, gender: u.gender, maxPower: u.maxMeanPower, maxWeight: u.maxWeight})));
      
      return result;
    }

    // Process Vertical Jump data for jump height leaderboards
    function processVerticalJumpData(sets, exerciseName = '') {
      const userStats = new Map();
      let validSets = 0;
      let setsWithReps = 0;
      let totalRepsProcessed = 0;
      let repsWithJumpData = 0;
      
      console.log(`Processing ${exerciseName} data for gender: ${currentGender}`);
      
      sets.forEach(set => {
        if (!set || !set.user_id) return;
        
        const userInfo = getUserInfo(set.user_id);
        if (!userInfo || userInfo.gender.toLowerCase() !== currentGender.toLowerCase()) return;
        
        validSets++;
        
        if (!userStats.has(set.user_id)) {
          userStats.set(set.user_id, {
            name: userInfo.name,
            gender: userInfo.gender,
            maxJumpHeight: 0
          });
        }
        
        const userStat = userStats.get(set.user_id);
        
        // Check set-level jump height data (already in inches)
        const setJumpHeight = set.max_jump_height || set.avg_jump_height || null;
        console.log(`Set ${set.id} jump height data: max=${set.max_jump_height}, avg=${set.avg_jump_height}, setJumpHeight=${setJumpHeight}`);
        
        if (setJumpHeight && setJumpHeight > userStat.maxJumpHeight) {
          userStat.maxJumpHeight = setJumpHeight;
          repsWithJumpData++;
          console.log(`${exerciseName} - Set-level jump height: ${setJumpHeight} in for user ${userInfo.name}`);
        }
        
        // Count reps for stats tracking only (don't process individual reps for vertical jump)
        if (set.reps && Array.isArray(set.reps) && set.reps.length > 0) {
          setsWithReps++;
          totalRepsProcessed += getValidReps(set).length;
        }
      });
      
      const result = Array.from(userStats.values());
      console.log(`Processed ${exerciseName} stats: ${validSets} sets, ${setsWithReps} with reps, ${totalRepsProcessed} total reps, ${repsWithJumpData} with jump data`);
      console.log(`Found ${result.length} users with data:`, result.map(u => ({name: u.name, gender: u.gender, maxJumpHeight: u.maxJumpHeight})));
      
      return result;
    }

    // Render leaderboard table
    function renderLeaderboard(data, tableBodyId, metricKey, unit) {
      const tableBody = document.getElementById(tableBodyId);
      
      if (data.length === 0) {
        const message = metricKey === 'maxPeakPower' 
          ? 'No power data available (untracked sets)' 
          : 'No data available';
        tableBody.innerHTML = `<tr><td colspan="3" class="loading">${message}</td></tr>`;
        return;
      }

      // Sort by metric (descending) and take top 10
      const sortedData = data
        .filter(user => user[metricKey] > 0)
        .sort((a, b) => b[metricKey] - a[metricKey])
        .slice(0, 10);

      if (sortedData.length === 0) {
        const message = metricKey === 'maxPeakPower' 
          ? 'No power data available (untracked sets)' 
          : 'No data available';
        tableBody.innerHTML = `<tr><td colspan="3" class="loading">${message}</td></tr>`;
        return;
      }

      const rows = sortedData.map((user, index) => {
        const rank = index + 1;
        let value;
        if (metricKey === 'maxMeanPower') {
          value = Math.round(user[metricKey]);
        } else if (metricKey === 'maxWeight') {
          value = Math.round(user[metricKey]); // Remove decimal for weights
        } else {
          value = user[metricKey].toFixed(1);
        }
        
        return `
          <tr>
            <td>${rank}</td>
            <td>${escapeHtml(user.name)}</td>
            <td>${value} ${unit}</td>
          </tr>
        `;
      }).join('');

      tableBody.innerHTML = rows;
    }

    // Switch gender and reload data
    async function switchGender(gender) {
      currentGender = gender;
      
      // Update active tab
      document.querySelectorAll('.gender-tab').forEach(tab => {
        tab.classList.remove('active');
      });
      document.querySelector(`[data-gender="${gender}"]`).classList.add('active');
      
      // Show loading state for all tables
      const tableIds = [
        'meanPowerTableBody', 'weightTableBody',
        'benchMeanPowerTableBody', 'benchWeightTableBody',
        'trapBarMeanPowerTableBody', 'trapBarWeightTableBody',
        'frontSquatMeanPowerTableBody', 'frontSquatWeightTableBody',
        'verticalJumpMaxHeightTableBody'
      ];
      
      tableIds.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
          element.innerHTML = '<tr><td colspan="3" class="loading">Loading...</td></tr>';
        }
      });
      
      // Load and display data
      await loadLeaderboards();
    }

    // Load and display leaderboards for all exercises
    async function loadLeaderboards() {
      // Load Back Squat data
      if (exerciseIds.backSquat) {
        const backSquatSets = await fetchExerciseData(exerciseIds.backSquat, 'Back Squat');
        const backSquatData = processLeaderboardData(backSquatSets, 'Back Squat');
        renderLeaderboard(backSquatData, 'meanPowerTableBody', 'maxMeanPower', 'W');
        renderLeaderboard(backSquatData, 'weightTableBody', 'maxWeight', 'lbs');
      }
      
      // Load Bench Press data
      if (exerciseIds.benchPress) {
        console.log('Loading Bench Press data with exercise ID:', exerciseIds.benchPress);
        const benchPressSets = await fetchExerciseData(exerciseIds.benchPress, 'Bench Press');
        console.log('Bench Press sets fetched:', benchPressSets.length);
        const benchPressData = processLeaderboardData(benchPressSets, 'Bench Press');
        console.log('Bench Press processed data:', benchPressData.length, 'users');
        renderLeaderboard(benchPressData, 'benchMeanPowerTableBody', 'maxMeanPower', 'W');
        renderLeaderboard(benchPressData, 'benchWeightTableBody', 'maxWeight', 'lbs');
      } else {
        console.error('Bench Press exercise ID not available, skipping data load');
      }
      
      // Load Trap Bar Deadlift data
      if (exerciseIds.trapBarDeadlift) {
        const trapBarSets = await fetchExerciseData(exerciseIds.trapBarDeadlift, 'Trap Bar Deadlift');
        const trapBarData = processLeaderboardData(trapBarSets, 'Trap Bar Deadlift');
        renderLeaderboard(trapBarData, 'trapBarMeanPowerTableBody', 'maxMeanPower', 'W');
        renderLeaderboard(trapBarData, 'trapBarWeightTableBody', 'maxWeight', 'lbs');
      } else {
        console.error('Trap Bar Deadlift exercise ID not available, skipping data load');
      }
      
      // Load Front Squat data
      if (exerciseIds.frontSquat) {
        const frontSquatSets = await fetchExerciseData(exerciseIds.frontSquat, 'Front Squat');
        const frontSquatData = processLeaderboardData(frontSquatSets, 'Front Squat');
        renderLeaderboard(frontSquatData, 'frontSquatMeanPowerTableBody', 'maxMeanPower', 'W');
        renderLeaderboard(frontSquatData, 'frontSquatWeightTableBody', 'maxWeight', 'lbs');
      }
      
      // Load Vertical Jump data
      if (exerciseIds.verticalJump) {
        console.log('Loading Vertical Jump data with exercise ID:', exerciseIds.verticalJump);
        const verticalJumpSets = await fetchExerciseData(exerciseIds.verticalJump, 'Vertical Jump');
        console.log('Vertical Jump sets fetched:', verticalJumpSets.length);
        const verticalJumpData = processVerticalJumpData(verticalJumpSets, 'Vertical Jump');
        console.log('Vertical Jump processed data:', verticalJumpData.length, 'users');
        renderLeaderboard(verticalJumpData, 'verticalJumpMaxHeightTableBody', 'maxJumpHeight', 'in');
      } else {
        console.error('Vertical Jump exercise ID not available, skipping data load');
      }
    }

    // Utility function to escape HTML
    function escapeHtml(str = '') {
      return str.replace(/[&<>"']/g, match => ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
      })[match]);
    }

    // Initialize page
    document.addEventListener('DOMContentLoaded', async () => {
      // Check authentication first
      if (!requireAthleteAuth()) {
        return; // Will redirect to login
      }
      console.log('Initializing Current Leaders page...');
      await loadExercises();
      await loadAllOrganizationUsers();
      await loadLeaderboards();
      
      // Auto-refresh every hour (3600000 milliseconds)
      setInterval(async () => {
        console.log('Auto-refreshing leaderboards...');
        await loadLeaderboards();
      }, 3600000);
    });
  </script>
</body>
</html>